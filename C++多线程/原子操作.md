## 1  原子操作

### 1.1  定义与特性

#### 1.1.1  定义

原子操作是**不可分割**的操作，要么完全执行成功，要么完全不执行，不存在中间状态。在多线程环境下，原子操作保证了**线程安全性**。

#### 1.1.2  三种特性

- **原子性**：操作是否不可分割
- **可见性**：一个线程的修改何时对其他线程可见
- **顺序性**：操作执行顺序是否可预测

### 1.2  内存模型与重排序

#### 1.2.1  问题示例

```cpp
// 非原子操作的可见性问题
int shared_data = 0;
bool ready = false;

// 线程1 - 写入数据
void writer() {
    shared_data = 42;  // ①
    ready = true;      // ②
    // 编译器和CPU可能重排序①和②
}

// 线程2 - 读取数据
void reader() {
    if (ready) {       // ③
        print(shared_data);  // 可能看到0而不是42
    }
}
```

### 1.3  基础原子操作

#### 1.3.1  load（加载）

- **原子读**：从内存中读取数据到寄存器或变量
- **可见性规则**：如果 load 操作看到某个 store 操作写入的值，且二者有适当的内存顺序关系，那么 load 操作也能看到该 store 操作之前所有的写操作
- **作用**：可以看见其他线程最新操作的数据

#### 1.3.2  store（存储）

- **原子写**：将数据从寄存器或变量写入内存
- **发布规则**：release store 确保在该 store 之前的所有内存操作不会被重排到该 store 之后，为数据发布提供了安全保证
- **作用**：使得当前线程修改的变量对其他线程可见

### 1.4  内存屏障（Memory Barrier）

内存屏障用于控制内存操作的顺序，防止重排序。以下是描述内存顺序约束的四种理论模型：

- **LoadLoad**：确保前面的 Load 操作先于后面的 Load 操作完成
- **StoreStore**：确保前面的 Store 操作先于后面的 Store 操作完成
- **LoadStore**：确保前面的 Load 操作先于后面的 Store 操作完成
- **StoreLoad**：确保前面的 Store 操作先于后面的 Load 操作完成（全能屏障，开销最大）

### 1.5  内存顺序（Memory Order）

#### 1.5.1  memory_order_relaxed

- 最宽松，没有顺序约束，只保证操作的原子性
- 不保证顺序性：允许编译器和 CPU 重新排序
- 不保证可见性：其他线程可能不会立即看到写入的值
- **性能最好**，适用于计数器等简单场景

#### 1.5.2  memory_order_consume

- 数据依赖顺序（在 C++17 中不推荐使用）

#### 1.5.3  memory_order_acquire（获取操作）

- 该操作**之后**的所有内存读/写操作，不能被重排序到 acquire 操作之前
- 确保 acquire 之后的操作都能看到之前其他线程的写入

#### 1.5.4  memory_order_release（释放操作）

- 该操作**之前**的所有内存写操作，不能被重排序到 release 操作之后
- 确保 release 之前的写入对发布后获取该值的线程可见

#### 1.5.5  memory_order_acq_rel

- 获取 - 释放，同时具有 acquire 和 release 的特性
- 常用于读 - 修改 - 写操作

#### 1.5.6  memory_order_seq_cst

- **顺序一致性**：所有线程看到的操作顺序是一致的
- 相当于所有的原子操作都被放在同一个全局的总顺序中
- 最严格的内存顺序，性能开销最大
- **C++ 原子操作的默认值**

### 1.6  同步关系

#### 1.6.1  release-acquire 同步模式

```cpp
// 线程1：发布数据
A;  // 数据准备操作
atomic.store(value, std::memory_order_release);  // B: 发布

// 线程2：获取数据
atomic.load(std::memory_order_acquire);  // C: 获取
D;  // 使用数据
```

**同步规则**：
1. 线程 1 中，A 操作**不能**重排到 B 之后
2. 线程 2 中，D 操作**不能**重排到 C 之前
3. 如果线程 2 的 load 操作读到了线程 1 的 store 操作写入的值，那么线程 1 的 A 操作对线程 2 的 D 操作是**可见的**

#### 1.6.2  核心原理

> 如果线程 A 的 release 操作与线程 B 的 acquire 操作同步于同一个原子变量，那么线程 A 在 release 之前的所有写操作对线程 B 在 acquire 之后的所有读操作都是可见的

### 1.7  总结对比

| 内存顺序 | 顺序保证 | 可见性保证 | 性能 | 适用场景 |
|---------|----------|------------|------|----------|
| `relaxed` | 无 | 无 | 最佳 | 计数器、统计 |
| `acquire` | 后序不重排到之前 | 部分 | 中等 | 读操作、锁获取 |
| `release` | 前序不重排到之后 | 部分 | 中等 | 写操作、锁释放 |
| `acq_rel` | acquire+release | 部分 | 中等 | RMW 操作 |
| `seq_cst` | 全局顺序 | 完全 | 最差 | 默认、简单模型 |

### 1.8  使用建议

1. **默认使用** `memory_order_seq_cst`，除非确定需要优化
2. 使用**release-acquire 配对**实现高效同步
3. 只在性能关键路径上使用 `memory_order_relaxed`
4. 避免使用 `memory_order_consume`（已不推荐）

## 2  示例 1: 最简单的原子屏障

```cpp
#include <algorithm>
#include <atomic>
#include <iostream>
#include <thread>

// 原子变量
std::atomic<int> count(0);

void set_count(int x){
    std::cout << "set_count: " << x << std::endl;
    count.store(x); // 原子写
}

void print_count(){
    int x;
    do{
        x = count.load(std::memory_order_relaxed); // 原子读，由于只有一个操作，因此使用最轻松的内存次序
    }while(x == 0);
    std::cout << "count: " << x << std::endl;
}

int main(){
    std::thread t1(print_count);
    std::thread t2(set_count, 10);

    t1.join();
    t2.join();

    std::cout << "main finish\n";
    return 0;
}
```

## 3  示例二：单例模式

```cpp
#include <cstdlib>
#include <mutex>
#include <atomic>
class Singleton{
public:
    static Singleton* GetInstance(){
        // 第一次检查，使用 relaxed，因为只关心 _instance 是否为空
        Singleton* tmp = _instance.load(std::memory_order_relaxed);

        // 获取内存屏障
        std::atomic_thread_fence(std::memory_order_acquire); 

        if(tmp == nullptr){
            std::lock_guard<std::mutex> lock(_mtx); 
            tmp = _instance.load(std::memory_order_relaxed); // 同上，仅用于检测用
            if(tmp == nullptr){
                tmp = new Singleton;

                // 释放内存屏障
		        std::atomic_thread_fence(std::memory_order_release);
                _instance.store(tmp, std::memory_order_relaxed);
                atexit(Destructor);
            }
        }

        return tmp;
    }
private:
    static void Destructor(){
        if(_instance != nullptr){
            delete _instance;
            _instance = nullptr;
        }
    }

    Singleton(){}; // 默认构造
    ~Singleton(){};
    Singleton(const Singleton&) = delete; // 拷贝构造
    Singleton& operator=(const Singleton&) = delete; // 拷贝赋值构造
    Singleton(Singleton&&) = delete; // 移动构造
    Singleton& operator=(Singleton&&) = delete;
    static std::atomic<Singleton*> _instance; // 移动拷贝构造
    static std::mutex _mtx;
};
std::atomic<Singleton*> Singleton::_instance = nullptr;
std::mutex Singleton::_mtx; // 互斥锁初始化
```
