## 1  概述

### 1.1  什么是互斥量

- **互斥量**（mutex，mutual exclusion 的缩写）是用于保护共享数据免于同时被多个线程访问的同步原语
- 基本思想：任何线程访问共享数据前，必须锁定互斥量；访问完成后，解锁互斥量
- 保证同一时间只有一个线程可以访问共享资源

### 1.2  头文件

```cpp
#include <mutex>
```

## 2  C++11 中的互斥量类型

C++11 提供四种互斥量：

| 类型 | 说明 | 递归 | 超时 |
|------|------|------|------|
| `std::mutex` | 基本互斥量 | ❌ | ❌ |
| `std::timed_mutex` | 带超时功能的互斥量 | ❌ | ✅ |
| `std::recursive_mutex` | 递归互斥量 | ✅ | ❌ |
| `std::recursive_timed_mutex` | 带超时的递归互斥量 | ✅ | ✅ |

## 3  互斥量 RAII 包装器：安全使用互斥量的关键

### 3.1  为什么需要 RAII 包装器

直接使用 `lock()` 和 `unlock()` 可能带来的问题：

1. **忘记解锁**：导致死锁
2. **异常安全问题**：临界区发生异常时，可能无法执行解锁操作
3. **代码维护困难**：需要在多个退出点手动解锁

### 3.2  `std::lock_guard`

- 最简单的 RAII 包装器，构造时加锁，析构时解锁
- **不可手动控制锁的生命周期**，生命周期完全由作用域控制
- 适用于简单的临界区保护
- **不可复制、不可移动**
- 轻量级，性能开销极小

```cpp
std::mutex mtx;

void safe_function() {
    std::lock_guard<std::mutex> lock(mtx);  // 构造时加锁
    // 临界区代码
    // 函数返回或异常时自动解锁
}
```

### 3.3  `std::unique_lock`

- 功能更强大的 RAII 包装器，提供更多控制
- 特性：
	- 支持延迟锁定（构造时不立即加锁）
	- 允许手动锁定/解锁
	- 支持锁所有权转移（可移动，不可复制）
	- 可与条件变量配合使用
	- 支持超时操作
	- 相比 `lock_guard` 有额外性能开销

```cpp
std::mutex mtx;

void flexible_function() {
    std::unique_lock<std::mutex> lock(mtx, std::defer_lock);  // 延迟锁定
    // … 一些不需要锁的操作 …
    lock.lock();  // 手动锁定
    // 临界区代码
    lock.unlock();  // 可手动解锁
    // … 更多操作 …
    // 析构时如果仍持有锁，会自动解锁
}
```

### 3.4  选择原则

- **简单场景**：使用 `lock_guard`，更高效
- **复杂场景**：需要条件变量、手动控制锁、锁所有权转移时，使用 `unique_lock`

> [!note] 为什么条件变量需要 unique_lock
> 条件变量 (std::condition_variable) 的 wait() 方法需要：
> - 原子地释放锁并阻塞线程
> - 被唤醒时重新获取锁
> 
> 这需要锁支持手动解锁/重新锁定，lock_guard 无法满足。

## 4  独占互斥量 `std::mutex`

### 4.1  成员函数

#### 4.1.1  构造函数

- `std::mutex` 不允许拷贝构造和移动构造（删除拷贝/移动构造函数）
- 新创建的 `mutex` 对象处于解锁状态

#### 4.1.2  `lock()`

- 锁定互斥量
- 行为：
  1. 如果互斥量当前未锁定，调用线程获得锁
  2. 如果互斥量已被其他线程锁定，当前线程阻塞直到获得锁
  3. 如果互斥量已被当前线程锁定（非递归锁），**导致未定义行为**（通常是死锁）

#### 4.1.3  `unlock()`

- 解锁互斥量
- 必须由锁的持有者调用

#### 4.1.4  `try_lock()`

- 尝试锁定互斥量，不阻塞
- 返回值：
  - `true`：成功获得锁
  - `false`：未能获得锁（已被其他线程锁定）
- 注意：如果互斥量已被当前线程锁定，**导致未定义行为**

### 4.2  基本使用示例

```cpp
#include <iostream>
#include <thread>
#include <mutex>

int counter = 0;
std::mutex mtx;

void increases_10k() {
    for (int i = 0; i < 1000; ++i) {
        // 方法1: 直接使用lock()/unlock()
        mtx.lock();
        ++counter;
        mtx.unlock();
        
        // 方法2: 使用try_lock()（非阻塞）
        // if (mtx.try_lock()) {
        //     ++counter;
        //     mtx.unlock();
        // }
    }
}

int main() {
    std::thread threads[10];
    for (int i = 0; i < 10; ++i) {
        threads[i] = std::thread(increases_10k);
    }

    for (auto& th : threads) th.join();
    std::cout << "Counter value: " << counter << std::endl;
    return 0;
}
```

### 4.3  更安全的 RAII 方式

```cpp
void safe_increases_10k() {
    for (int i = 0; i < 1000; ++i) {
        // 使用lock_guard，异常安全
        std::lock_guard<std::mutex> lock(mtx);
        ++counter;
        
        // 锁在lock_guard析构时自动释放
    }
}
```

## 5  递归互斥量 `std::recursive_mutex`

### 5.1  与 `std::mutex` 的区别

- **`std::mutex`**：同一线程重复加锁会导致未定义行为（通常死锁）
- **`std::recursive_mutex`**：允许同一线程多次加锁，需要相同次数的解锁操作

### 5.2  使用场景

当函数会递归调用自身，或调用其他也需要锁的函数时：

```cpp
#include <iostream>
#include <mutex>

class Complex {
private:
    std::recursive_mutex mtx;
    double value;
    
public:
    Complex() : value(3.0) {}
    
    void multiply(int x) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        value *= x;
    }
    
    void divide(int x) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        value /= x;
    }
    
    // 这个函数会调用其他也需要锁的函数
    void both(int x, int y) {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        multiply(x);  // 需要再次获取锁
        divide(y);    // 需要再次获取锁
        // 使用递归锁可以正常工作
        // 如果使用普通mutex，这里会导致死锁
    }
    
    void print() {
        std::lock_guard<std::recursive_mutex> lock(mtx);
        std::cout << "Value: " << value << std::endl;
    }
};

int main() {
    Complex complex;
    complex.both(32, 23);
    complex.print();
    return 0;
}
```

### 5.3  递归锁的注意事项

1. **尽量避免使用**：递归锁通常意味着设计有问题，可以重构代码避免递归加锁
2. **性能开销**：递归锁比普通锁有额外的性能开销
3. **最大递归深度**：标准未指定，但达到系统限制时会抛出 `std::system_error`
4. **死锁风险**：仍然可能与其他锁产生死锁

## 6  带超时的互斥量

### 6.1  `std::timed_mutex`

在 `std::mutex` 基础上增加超时功能：

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

std::timed_mutex tmtx;

void thread_func(int id) {
    // 尝试获取锁，最多等待100ms
    if (tmtx.try_lock_for(std::chrono::milliseconds(100))) {
        std::cout << "Thread " << id << " acquired lock" << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
        tmtx.unlock();
    } else {
        std::cout << "Thread " << id << " failed to acquire lock" << std::endl;
    }
}

int main() {
    std::thread t1(thread_func, 1);
    std::thread t2(thread_func, 2);
    
    t1.join();
    t2.join();
    return 0;
}
```

### 6.2  `std::recursive_timed_mutex`

递归锁与超时功能的结合。

## 7  最佳实践总结

1. **优先使用 RAII 包装器**：总是使用 `lock_guard` 或 `unique_lock`，避免直接调用 `lock()/unlock()`
2. **简单场景用 `lock_guard`**：如果只是简单保护临界区，使用 `lock_guard`
3. **复杂场景用 `unique_lock`**：需要条件变量、手动控制、所有权转移时使用
4. **避免递归锁**：尽量通过重构代码避免使用递归互斥量
5. **锁的粒度要小**：锁保护的临界区应尽可能小，减少锁竞争
6. **避免嵌套锁**：尽量避免一个函数内获取多个锁，容易导致死锁
7. **按固定顺序获取锁**：如果必须获取多个锁，所有线程应按相同顺序获取
8. **使用 `std::lock()` 处理多个锁**：C++11 提供 `std::lock()` 可一次性锁定多个互斥量，避免死锁

## 8  补充：C++17 的改进

C++17 引入了 `std::scoped_lock`，可以更安全地处理多个互斥量：

```cpp
#include <mutex>

std::mutex mtx1, mtx2;

void safe_with_multiple_locks() {
    // C++17: 锁定多个互斥量，避免死锁
    std::scoped_lock lock(mtx1, mtx2);
    
    // 临界区代码
    // 析构时自动解锁所有互斥量
}
```

`std::scoped_lock` 比 `std::lock_guard` 更灵活，推荐在 C++17 及以上版本使用。
