## 1  头文件：zero_thread.h

```cpp
#ifndef ZERO_THREAD_H
#define ZERO_THREAD_H

#include <memory>
#include <thread>
class ZERO_Thread{
public:
    ZERO_Thread(); 
    virtual ~ZERO_Thread();

    bool start();
    void stop();
    bool isAlive() const;
    std::thread::id id(){
        if(th_ && *th_ && (*th_)->joinable()){
            return (*th_)->get_id();
        }else{
            return std::thread::id();
        }
    }
    std::shared_ptr<std::thread*> getThread(){return th_;}
    void join(); // 等待当前线程结束，不能在当前线程上调用
    void detach(); // 能在当前线程上调用
    static size_t CURRENT_THREADID(); // 该函数

protected:                                                                     
    void threadEntry();
    virtual void run() = 0;

protected:
    bool running_; // 是否在运行
    std::shared_ptr<std::thread*> th_; // 当前线程
};

#endif // ZERO_THREAD_H
```

## 2  实现：zero_thread.cpp

```cpp
#include "zero_thread.h"
#include <cstddef>
#include <cstdlib>
#include <sstream>
#include <iostream>
#include <exception>
#include <thread>
#include <memory>

// 构造函数
ZERO_Thread::ZERO_Thread():running_(false), th_(std::make_shared<std::thread*>()){}

// 析构函数
ZERO_Thread::~ZERO_Thread(){
    if(th_!=nullptr && (*th_)!=NULL){
        // 
        if((*th_)->joinable()){
            std::cout << "~ZERO_Thread detach\n";
            (*th_)->detach();
        }
        th_ = NULL;
    }
    std::cout << "~ZERO_Thread detach\n";
}

// 线程开始
bool ZERO_Thread::start(){
    if(running_){
        return false;
    }
    try {
        // 创建线程
        th_ = std::make_shared<std::thread*>(new std::thread(&ZERO_Thread::threadEntry, this));
    } catch (…) {
        throw "[ZERO_Thread::start] thread start error";
    }
    return true;
}

// 线程结束
void ZERO_Thread::stop(){
    running_ = false;
}

// 线程状态
bool ZERO_Thread::isAlive() const{
    return running_;
}

// join
void ZERO_Thread::join(){
    if((*th_)->joinable()){
        (*th_)->join();
    }
}

// 分离
void ZERO_Thread::detach(){
    (*th_)->detach();
}

// 获取当前线程ID
size_t ZERO_Thread::CURRENT_THREADID(){

    // thread_local 的本地变量在线程中持续存在
    // thread_local 声明的变量初始化特征和生命周期和 static 是一致的，即使不被声明为 static
    static thread_local size_t threadID = 0;
    if(threadID == 0){
        std::stringstream ss;
        ss << std::this_thread::get_id();
        threadID = strtol(ss.str().c_str(), NULL, 0);
    }
    return threadID;
}

// 线程入口
void ZERO_Thread::threadEntry(){
    running_ = true;

    try{
        run(); // 子类的业务处理函数
    }catch(std::exception &ex){
        running_ = false;
        throw ex;
    }catch(…){
        running_ = false;
        throw;
    }
    running_ = false;
}
```

## 3  主程序：main.cpp

```cpp
#include <iostream>
#include <chrono>
#include <thread>
#include "zero_thread.h"
using namespace std;
/*

    封装线程的目的
    - 子类能够继承封装的线程
    - 子类能够实现具体的处理逻辑
*/

class A: public ZERO_Thread{
public:
    void run(){
        while (running_) {
            cout << "print A" << endl;
            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
        cout << "------ leave A" << endl;
    }
};

class B: public ZERO_Thread{
public:
    void run(){
        while (running_) {
            cout << "print B" << endl;
            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
        cout << "------ leave B" << endl;
    }
};

int main(){
    {
        A a;
        a.start();
        B b;
        b.start();
        std::this_thread::sleep_for(std::chrono::seconds(5));

        a.stop();
        a.join();

        b.stop();
        b.join();
    }
    cout << ">>>>>>>>" << endl;
    return 0;
}
```
