## 1  main.cpp

```cpp
#include "zero_threadpool.h"
#include <functional>
#include <iostream>

using namespace std;
void func(){
    cout << "func()" << endl;
}

void func1(int a)
{
    cout << "func1() int a= " << a << endl;
}

// void func1(string a)
// {
//     cout << "func1() string a= " << a << endl;
// }

void func2(int a, string b)
{
    cout << "func1() a= " << a << ", b= " << b <<endl;
}

/*
    简单测试案例
*/
void test1(){
     Zero_ThreadPool  zero_threadpool;
     zero_threadpool.init(1);
     zero_threadpool.start();
     zero_threadpool.exec(1000, func1, 10);
     zero_threadpool.exec(1000, func2, 10, "daring");
     zero_threadpool.waitForAllDone(-1);
     zero_threadpool.stop();
}

int func1_future(int a){
    cout << "func1_future a=" << a << endl;
    return a;
}

string func2_future(int a, string b){
    cout << "func2_future a=" << a << ", b=" << b << endl;
    return b;
}

void test2(){
    Zero_ThreadPool zero_ThreadPool;
    zero_ThreadPool.init(1);
    zero_ThreadPool.start();

    // 要执行的任务
    auto res1 = zero_ThreadPool.exec(1000, func1_future, 10);
    auto res2 = zero_ThreadPool.exec(1000, func2_future, 20, "king");

    std::cout << "result1: " << res1.get() << std::endl;
    std::cout << "result2: " << res2.get() << std::endl;

    zero_ThreadPool.waitForAllDone(-1);
    zero_ThreadPool.stop();
}

class Test{
public:
    int test(int i){
        cout << _name << ", i=" << i << endl;
        return i;
    }
    void setName(string name){
        _name = name;
    }

    string _name;
};

void test3(){
    Zero_ThreadPool  zero_threadpool;
    zero_threadpool.init(1);
    zero_threadpool.start();
    Test t1;
    Test t2;
    t1.setName("king");
    t2.setName("daring");
    // zero_threadpool.exec(1000,
    //     std::bind(&Test::test, &t1, std::placeholders::_1), 
    //     5);
    // zero_threadpool.exec(1000, 
    //     std::bind(&Test::test, &t2, std::placeholders::_1), 
    //     100);

    // 优化 1：直接绑定参数
    // zero_threadpool.exec(1000,
    //     std::bind(&Test::test, &t1, 5));
    // zero_threadpool.exec(1000, 
    //     std::bind(&Test::test, &t2, 100));
    
    // 使用 lambda 表达式
    zero_threadpool.exec(1000, [&t1]{ return t1.test(5); });
    zero_threadpool.exec(1000, [&t2]{ return t2.test(100); });

    zero_threadpool.waitForAllDone(-1);
    zero_threadpool.stop();
}
int main(){
    // test1();
    // test2();
    test3();
    return 0;
}
```

## 2  zero_threadpool.h

```cpp
#ifndef ZERO_THREADPOOL_H
#define ZERO_THREADPOOL_H

#include <condition_variable>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <thread>
#include <future>
#include <string>
#include <utility>
#include <vector>
#include <atomic>
#include <queue>
#include <functional>

#define TNOWMS 100

class Zero_ThreadPool{
protected:
    struct TaskFunc{
        TaskFunc(uint64_t expireTime):_expireTime(expireTime){}
        std::function<void()> _func;    // 运行函数
        int64_t _expireTime;    // 超时的绝对时间
    };

    typedef std::shared_ptr<TaskFunc> TaskFuncPtr;
public:
    Zero_ThreadPool();
    ~Zero_ThreadPool();

    bool init(int num); // 设置线程数量
    bool start(); // 创建线程
    bool waitForAllDone(int millsecond); // 等待所有任务都执行完，退出
    void stop(); // 真正的退出
    /*
        执行
    */
    template <class F, class… Args>
    auto exec(int64_t timeoutMS, F&& f, Args&&… args) 
        -> std::future<decltype(f(args…))>{
        // 计算超时时间
        int64_t expireTime = (timeoutMS == 0 ? 0 : TNOWMS + timeoutMS);

        // 定义返回值类型
        using RetType = decltype(f(args…));

        // 封装任务
        // 任务为 F f
        // 返回 future
        auto task = std::make_shared<std::packaged_task<RetType()>>(
            std::bind(std::forward<F>(f), std::forward<Args>(args)…)
        );

        // 任务信息设置
        TaskFuncPtr fptr = std::make_shared<TaskFunc>(expireTime);// 封装任务指针，设置过期时间
        fptr->_func = [task](){ // 具体执行函数
            (*task)();
        };

        // 添加到任务队列
        std::unique_lock<std::mutex> locker(_mutex);
        _tasks.push(fptr);
        _cond.notify_one();

        return task->get_future();
    }
    
protected:
    /*
        获取任务
    */
    bool get(TaskFuncPtr& task);

    /*
        线程池是否退出
    */
    bool isTerminate(){return _bTerminate;}

    /*
        线程运行态
    */
    void run();
protected:
    std::queue<TaskFuncPtr> _tasks; // 任务队列
    std::size_t _threadNums; // 线程数量
    bool _bTerminate; // 线程是否结束
    std::mutex _mutex; // 锁
    std::condition_variable _cond;
    std::vector<std::thread> _threads; // 工作线程
    std::atomic<int> _atomic{0}; // 线程计数
};

#endif // ZERO_THREADPOOL_H
```

## 3  zero_threadpool.cpp

```cpp
#include "zero_threadpool.h"
#include <chrono>
#include <mutex>
#include <utility>

Zero_ThreadPool::Zero_ThreadPool():_threadNums(1), _bTerminate(false){}

Zero_ThreadPool::~Zero_ThreadPool(){
    stop();
}

/*
    初始化，设置线程的数量
*/
bool Zero_ThreadPool::init(int num){
    std::unique_lock<std::mutex> locker(_mutex);

    if(!_threads.empty()){
        return false;
    }

    _threadNums = num; // 设置线程数量
    return true;
}

/*
    创建线程
    - 如果线程已经创建，则直接返回
    - 否则，创建线程
*/
bool Zero_ThreadPool::start(){

    std::lock_guard<std::mutex> locker(_mutex);

    if(!_threads.empty()){
        return false;
    }

    // 创建线程
    for(size_t i = 0; i < _threadNums; ++i){
        // 优化：之前 _threads 中存放的是 thread指针，现在直接存放对象
        // _threads.emplace_back(new std::thread(&Zero_ThreadPool::run, this));
        _threads.emplace_back(&Zero_ThreadPool::run, this);
    }

    return true;
}

/*

*/
void Zero_ThreadPool::stop(){
    {
        std::unique_lock<std::mutex> locker(_mutex);
        _bTerminate = true; // 触发退出 
        _cond.notify_all();
    }

    // 释放线程
    for(size_t i = 0; i < _threads.size(); ++i){
        if(_threads[i].joinable()){
            _threads[i].join();
        }
    }

    {
        std::lock_guard<std::mutex> locker(_mutex);
        _threads.clear();
    }
}

/*
    获取任务
*/
bool Zero_ThreadPool::get(TaskFuncPtr& task){
    std::unique_lock<std::mutex> locker(_mutex);

    // 任务队列空
    if(_tasks.empty()){
        _cond.wait(locker, 
            [this]{return _bTerminate || !_tasks.empty();} );
    } // notify -> 1. 要退出线程池 2. 任务队列非空

    // 如果线程结束
    if(_bTerminate)
        return false;

    if(!_tasks.empty()){
        task = std::move(_tasks.front()); // 获取任务
        _tasks.pop();
        return true;
    }

    return false;
}

/*
    每个线程的运行函数
*/
void Zero_ThreadPool::run(){
    while (!isTerminate()) {
        TaskFuncPtr task;
        bool ok = get(task); // 1. 读取任务
        if(ok){
            ++_atomic;
            try{
                if(task->_expireTime != 0 && task->_expireTime < TNOWMS){
                    // 超时任务 todo…
                }else{
                    task->_func(); // 2. 执行任务
                }
            }catch(…){

            }
            --_atomic;

            // 3. 检测是否所有任务执行完毕
            std::unique_lock<std::mutex> locker(_mutex);
            // 为什么这里还需要判断 _atomic
            // 因为 push 和 pop不是原子操作，不具备线程安全性
            // _atomic 是原子变量，记录了线程运行的个数
            // 当 _atomic == 0 时，就是没有线程在运行
            // 当没有线程运行且任务队列中不存在任务时，说明所有任务都已经执行完毕了
            if(_atomic == 0 && _tasks.empty()){
                _cond.notify_all();
            }
        }
    }
}

// 等待所有退出
bool Zero_ThreadPool::waitForAllDone(int millsecond){
    std::unique_lock<std::mutex> locker(_mutex);

    if(_tasks.empty()){
        return true;
    }

    if(millsecond < 0){
        _cond.wait(locker, [this]{ return _tasks.empty(); } );
        return true;
    }else{ // 设置超时
        return _cond.wait_for(locker, 
            std::chrono::microseconds(millsecond),
            [this]{ return _tasks.empty(); }
        );
    }
}
```
