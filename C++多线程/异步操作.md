## 1  头文件

```cpp
#include <future>
```

## 2  异步函数

### 2.1  std::aysnc

#### 2.1.1  功能

异步运行某个任务函数，并返回一个 std::future 来保存结果

#### 2.1.2  函数原型

```cpp
template< class F, class… Args >
std::future</* see below */> async( F&& f, Args&&… args );

template< class F, class… Args >
std::future</* see below */> async( std::launch policy,
                                    F&& f, Args&&… args );
```

- 参数
	- f：可调用的对象
	- args：传递给 f 的参数
	- policy：位掩码值，每个位控制允许的执行方法
- 返回值
	- 成功：std::future
	- 失败

#### 2.1.3  补充

- f 和 args 中的参数都需要支持移动构造

### 2.2  std::future

#### 2.2.1  功能

类模板 std：：future 提供了一种访问异步操作结果的机制

- 一个异步操作（通过 std：：future、std：：packaged_task 或 std：：promise 创建）可以向该异步操作的创建者提供一个 std：：future 对象。
- 然后，异步操作的创建者可以使用各种方法来查询、等待或从 std：：future 中提取值。**如果异步操作尚未提供值，则这些方法可能会阻塞。**
- 当异步操作准备好向创建者发送结果时，它可以通过修改链接到创建者的 std：：future 的共享状态（例如 std：：promise：：set_value）来完成。

std::future 引用的 shared_state 是不和其他异步操作返回结果共享的（和 std::shared_future 不同）

#### 2.2.2  函数原型

```cpp
template< class T > class future;

template< class T > class future<T&>;

template<> class future<void>;
```

#### 2.2.3  成员函数

##### 2.2.4 get

功能：从 future 中提取值，如果异步操作尚未提供值，则会阻塞等待异步操作的返回

#### 2.2.4  示例

```cpp
#include <chrono>
#include <future>
#include <ostream>
#include <thread>
#include <condition_variable>
#include <iostream>
using namespace std;

int find_result_to_add(){
    this_thread::sleep_for(std::chrono::seconds(5));
    std::cout << "find_result_to_add\n";
    return 1;
}

int find_result_to_add2(int a, int b){
    this_thread::sleep_for(std::chrono::seconds(5));
    return a + b;
}

void do_other_things(){
    cout << "do_other_things" <<endl;
}

int main(){
    // std::future<int> result = std::async(find_result_to_add); // 1
    // std::future<decltype (find_result_to_add())> result = std::async(find_result_to_add); // 2 自动推导类型
    // auto result = std::async(find_result_to_add); // 3
    // do_other_things();
    // std::cout << "result: " << result.get() << std::endl; // get 会阻塞等待 async 的返回

    // 当使用 decltype 推导有参函数的返回类型时，需要传入和形参一样类型的右值，如下
    std::future<decltype(find_result_to_add2(1, 1))> result = std::async(find_result_to_add2, 1, 1);
    std::cout << "result: " << result.get() << std::endl;

    std::cout << "main finish\n" << std::flush;
    return 0;
}
```

### 2.3  shared_future

#### 2.3.1  功能

- 类模板 std：：shared_future 提供了一种访问异步操作结果的机制，类似于 std：：future，不同之处在于允许多个线程等待相同的共享状态。
- 不同的地方是 std：：future 只能移动（因此只有一个实例可以引用任何特定的异步结果）；而 std：：shared_future 是可复制的，多个共享的 future 对象可以引用相同的共享状态。

#### 2.3.2  函数原型

```cpp
template< class T > class shared_future;

template< class T > class shared_future<T&>;

template<> class shared_future<void>;
```

### 2.4  std::packaged_task

#### 2.4.1  功能

- 封装一个函数来存储它的返回值，以便进行异步检索
- 也就是，将任务函数和 `std::future` 绑定在一起的模板

#### 2.4.2  函数原型

```cpp
template< class >
class packaged_task;

template< class R, class …ArgTypes >
class packaged_task<R(ArgTypes…)>;
```

- R：函数返回值类型
- ArgTypes…：要传递给函数的参数类型

#### 2.4.3  示例

```cpp
#include <future>
#include <iostream>

int add(int a, int b, int c){
    std::cout << "add\n";
    return a+b+c;
}

void do_something_else(){
    std::cout << "do_something_else\n";
}

int main(){
    std::packaged_task<int(int, int, int)> task(add); // 封装任务
    do_something_else();
    auto res = task.get_future(); // 获取 future
    task(1, 1, 2); // 任务执行
    // task(2, 2, 2); // 任务执行 error，packaged_task 只能使用一次
    // auto res = task.get_future(); // 可以在执行后获取
    std::cout << "result: " << res.get() << std::endl;
    return 0;
}
```

### 2.5  std::promise

#### 2.5.1  功能

类模板 std：：promise 提供了一个工具来存储一个值或一个异常，这些值或异常稍后通过 std：：promise 对象创建的 std：：future 对象异步获取。

- 每一个 std::promise 对象都和一个 shared state 相关联。其中，std::promise 可以对这个 shared state 做三种事情
	- make ready：将结果或异常存储在 shared state 中。将状态标记为就绪，并解除对等待与 shared state 相关联的 std::future 所属线程的阻塞。
	- release：std::promis 放弃对 shared state 的引用。
		- 当这个 shared state 没有其他引用时，将会被销毁。类似于 fd 减 1。
		- 只有当这个 shared state 是由 std::async 创建的，这个操作才会被阻塞
	- abandon：std::promise 存储异常类型 std::future_error 以及错误代码 std::future_errc::broken_promise，接着对该 shared state 进行 make ready 以及 release。
- std：：promise 对象只能使用一次。

#### 2.5.2  函数原型

```cpp
// 基本模板
template< class R > class promise;

// 非空特化，用于线程通信
template< class R > class promise<R&>;

// void 特化，用于通信无状态事件
template<> class promise<void>;
```

#### 2.5.3  成员函数

##### get_value

作用：返回一个 std::future

##### set_value

作用：设置结果为特定值

##### set_value_at_thread_exit

作用：仅当线程退出通知时，设置结果为特定值

##### set_exception

作用：设置结果以表示一个异常

##### set_exception_at_thread_exit

## 3  std::aysnc 和 std::future

### 3.1  std::future 的使用

- 模板参数： std::future 是一个模板，模板参数为期待返回的类型
- 同步访问：其虽然被用于线程通信，但是本身不提供同步访问，因此，必须通过互斥量或其他同步机制来保护访问。
- 使用时机：不需要立即得到某个结果
