## 1  头文件

```cpp
#include < condition_variable>
```

## 2  使用

### 2.1  和互斥量的区别

- 互斥量是多线程同时访问某一共享变量的安全访问的手段
- 条件变量则是实现线程同步的重要手段
	- 线程同步：线程间需要按照某种预定的先后次序顺序执行的行为
	- 通过条件变量的 wait 和 notify 两类操作实现线程同步

### 2.2  条件变量的使用过程

1. 拥有条件变量的线程获取互斥量
2. 循环检查某个条件，如果条件不满足则一直阻塞，直到条件满足；如果条件满足，则向下执行
3. 某个线程满足条件，执行 notify_one 或 notify_all，唤醒等待线程

## 3  成员函数

### 3.1  wait

```cpp
void wait( std::unique_lock<std::mutex>& lock );

template< class Predicate >
void wait( std::unique_lock<std::mutex>& lock, Predicate pred );
```

- 作用：导致当前线程阻塞，直到通知条件变量或出现虚假唤醒。
- 参数
	- lock：必须有唤醒线程锁定的锁
	- pred：检查等待是否可以完成的谓词
		- 谓词必须是函数对象
		- 谓词必须为有效表达式，且类型和值必须可以转化为 bool 类型

### 3.2  wait_for

```cpp
template< class Rep, class Period >
std::cv_status wait_for( std::unique_lock<std::mutex>& lock,
        const std::chrono::duration<Rep, Period>& rel_time );
        
template< class Rep, class Period, class Predicate >
bool wait_for( std::unique_lock<std::mutex>& lock,
	    const std::chrono::duration<Rep, Period>& rel_time,
        Predicate pred );
```

- 作用：导致当前线程阻塞，直到以下三种情况
	- 条件变量被通知
	- 超时
	- 虚假唤醒
- 参数
	- lock：必须有唤醒线程锁定的锁
	- rel_time：最大可持续时间
	- pred：检查等待是否可以完成的谓词
- 返回值
	1. 如果超时，返回 `std::cv_status::timeout`；否则，返回 `std::cv_status::no_timeout`
	2. 返回 pred 的结果

> [!note] 和 wait 相比，wait_for 仅仅多了个等待时间
> wait_for 比 wait 多了个等待时间

### 3.3  wait_until

```cpp
template< class Clock, class Duration >
std::cv_status wait_until( std::unique_lock<std::mutex>& lock,
        const std::chrono::time_point<Clock, Duration>& abs_time );
                
template< class Clock, class Duration, class Predicate >
bool wait_until( std::unique_lock<std::mutex>& lock,
        const std::chrono::time_point<Clock, Duration>& abs_time,
        Predicate pred );
```

- 作用：导致当前线程阻塞，直到以下三种情况
	- 条件变量被通知
	- 到达给定时间点
	- 虚假唤醒
- 参数
	- lock：必须有唤醒线程锁定的锁
	- abs_time：等待结束的时间点
	- pred：检查等待是否可以完成的谓词
- 返回值
	1. 如果超时，返回 `std::cv_status::timeout`；否则，返回 `std::cv_status::no_timeout`
	2. 返回 pred 的结果

> [!note] 和 wait_for 相比，只有中间的时间的区别
> - wait_for 是等待的时间
> - wait_until 是等待结束的时间点
> - 其余性质一样

### 3.4  notify_one

```cpp
void notify_one() noexcept;
```

- 作用：如果有任何线程正在等待 \*this，调用 notify_one 会解除阻塞其中一个等待的线程。

### 3.5  notify_all

```cpp
void notify_all() noexcept;
```

- 作用：对全部等待 \*this 的线程解锁阻塞

## 4  示例：同步队列

```cpp
#ifndef SYNC_QUEUE_H
#define SYNC_QUEUE_H

#include <cstddef>
#include <functional>
#include <list>
#include <mutex>
#include <thread>
#include <condition_variable>
#include <iostream>

template<typename T>
class SyncQueue{
private:
    bool isFull() const{
        return _queue.size() == _maxsize;
    }

    bool isEmpty() const{
        return _queue.empty();
    }
public:
    SyncQueue(std::size_t maxsize):_maxsize(maxsize){}

    // 插入数据
    void put(const T& x){
        std::unique_lock<std::mutex> locker(_mutex);

        // 如果满则等待，否则插入
        _cond.wait(locker, [this](){ return !isFull(); });

        _queue.push_back(x);
        _cond.notify_one();
    }

    // 取数据
    void take(T& x){
        std::unique_lock<std::mutex> locker(_mutex);

        // 如果空则等待，否则插入
        _cond.wait(locker, [this](){return !isEmpty();});

        x = std::move(_queue.front());

        _queue.pop_front();
        _cond.notify_one();
    }

    bool empty(){
        std::lock_guard<std::mutex> locker(_mutex);
        return _queue.empty();
    }

    bool full(){
        std::lock_guard<std::mutex> locker(_mutex);
        return _queue.size() == _maxsize;
    }

    size_t size(){
        std::lock_guard<std::mutex> locker(_mutex);
        return _queue.size();
    }
private:

    std::list<T> _queue; // 数据存储
    std::mutex _mutex;
    std::condition_variable _cond; // 条件变量
    size_t _maxsize;
};

#endif
```

main.cpp

```cpp
#include <thread>
#include "sync_queue.h"
#include <iostream>

SyncQueue<int> syncQueue(5);

void putDatas(){
    for(int i = 0; i < 20; ++i){
        syncQueue.put(1000+i);
    }
    std::cout << "putDatas finish\n"; 
}

void takeDatas(){
    int x = 0;
    for(int i = 0; i < 20; ++i){
        syncQueue.take(x);
        std::cout << "data: " << x << "\n" << std::flush;
    }
    std::cout << "takeDatas finish\n" << std::flush;
}

int main(void)
{
    std::thread t1(putDatas);
    std::thread t2(takeDatas);

    t1.join();
    t2.join();

    std::cout << "main finish\n";
    return 0;
}
```
