## 1  标准 C 库 I/O 流程

![标准C库IO](标准C库IO.md|1000.md)

+ 标准C库 I/O 存在缓冲区，将磁盘写入写出的操作批量进行
+ 通过文件指针，磁盘文件进行操作

## 2  头文件

C语言的标准输入输出函数，需要包含头文件`<stdio.h>`

## 3  标准输入输出流

### 3.1  stdin 标准输入流

+ `stdin`输入流，是一个文件描述符(Linux)或者文件句柄(Windows)。其对应着输入区域，通常指键盘设备的输入。在绝大多数时候`stdin`可以被直接认为是**键盘缓冲区**。由于Unix的I/O重定向，可以将文件流重定向到任意文件和设备中，所以这里把`stdin`视为一个对应输入的文件。
+ `stdin`是**行缓冲I/O**。在使用键盘键入字符的时候，键入的字符会被放到键盘自身的缓存中(键盘硬件设备中的一部分)。在遇到**换行符**后，操作系统才会进行同步，将键盘缓存中的字符读入到`stdin`对应的内存中，叫做**输入缓存区**。所有从`stdin`读取数据的函数，都是从电脑内存中的输入缓存区读入数据。

### 3.2  stdout 标准输出流

+ `stdout`输出流。对应输出区域，通常指屏幕设备的输出，被认为是**屏幕缓冲区**。
+ `stdout`是**行缓冲I/O**。用户打印数据时，数据首先从用户输出到`stdout`所对应的**输出缓冲区中**。

数据只有遇到如下几种情况，才会从 stdout 输出缓冲区到显示设备上打印

 + 缓存遇到了换行符`\n`
 + 缓存满了
	 + 缓存满了会自动清空，所以本质上也是缓存被刷新
 + 缓存被刷新了
	 + 程序结束时，会自动清空缓冲区
	 + 使用`fflush()`函数，一般这个函数是用来刷新输出(stdout)缓存的
 + stdout 被关闭

>[!question] 为什么使用 `printf()` 函数打印，没有添加 `\n`，数据仍然会正常打印
>当没有添加 `\n` 时，打印操作实际上是发生在程序结束后或stdout 被关闭时发生的。

### 3.3  stderr错误输出流

`stderr`是标准错误流，是**无缓冲的**，会立即输出到文件或输出设备上。

## 4  输入函数

### 4.1  scanf() 函数

功能

+ 格式化输入函数
+ **从标准输入流`stdin`中读取输入，并按照提供的`format`来浏览输入
+ **打印引号内字符串 ，将格式说明符替换成对应变量

函数原型

```C
#include <stdio.h>

int scanf(const char *restrict format, ...);
```

+ 参数
+ 返回值
	+ 成功：返回成功匹配和赋值的个数。
	+ 失败：如果到达文件末尾或发生错误，则返回`EOF`

```C
int fgetc(FILE *stream);
int getc(FILE *stream);
int getchar(void);

char *fgets(char s[restrict size], int size, FILE *restrict stream);
int ungetc(int c, FILE *stream);
```

### 4.2  fgetc()、getc()、getchar()

+ fgetc() 从流中读取下一个字符，并将其作为 unsigned char 强制转换为 int 类型返回，或在到达文件末尾或出现错误时返回 EOF。
+ getc() 等同于 fgetc()，不同之处在于它可以实现为一个宏，该宏可以多次执行 stream。
+ getchar() 等同于 getc(stdin)。

```C
int fgetc(FILE *stream);
int getc(FILE *stream);
int getchar(void);
```

+ 参数
	+ steam：流
+ 返回值
	+ 成功：返回得到的 unsigned char 的整型值
	+ 失败：EOF

### 4.3  fgets()

功能

+ fgets() 从 stream 中读取最多小于 size 个字符的字符，并将其存储到 s 指向的缓冲区中。
+ 读取操作在 EOF 或换行符后停止。如果读取到换行符，则将其存储到缓冲区中。
+ 在缓冲区的最后一个字符后存储一个终止空字节 ('\0')。

函数原型

```C
#include <stdio.h>

char *fgets(char s[restrict size], int size, FILE *restrict stream);
```

+ 参数
	+ s：输入缓冲区
	+ size：要读取的字符数。要小于等于`sizeof(s)-1`，因为缓冲区最后一个字符为 `\0`
	+ stream：流
+ 返回值
	+ 成功：s
	+ 失败：NULL

### 4.4  fread()

+ 函数 fread() 从 stream 指向的流中读取 n 个数据项，每个数据项长度为 size 字节，并将它们存储在 ptr 指定的位置。

```C
size_t fread(size_t size, size_t n;
                    void ptr[restrict size * n],
                    size_t size, size_t n,
                    FILE *restrict stream);

```

+ 参数
	+ ptr：输入缓冲区
	+ size：每个数据项的大小
	+ n：要读取数据项的数目
	+ stream：指定的流
+ 返回值
	+ 成功：读入的数据项的数目

>[!note] fread() 不区分错误
>需要使用 feof() 和 ferror() 来确定是否发生错误，以及在什么地方发生错误

## 5  输出函数

输出操作一般没有针对空格、制表符的特殊行为，只有换行符`\n`需要特殊对待。

### 5.1  printf()

功能

+ 把输出写入到标准输出流`stdout`中，根据提供的`format`产生输出
+ print format

函数原型

```C
int printf(const char *restrict format, ...);
```

+ 参数
	+ format：格式化字符串，包括要写入的标准输出文本以及格式控制符
	+ …：输出列表，要与格式控制符一一对应
+ 返回值
	+ 成功：返回写入的字符总数
	+ 失败：-1，并设置 errno

### 5.2  fputc()、putc() 和 putchar()

+ fputc() 将字符 c 强制转换为 unsigned char，写入 stream。
+ putc() 和 fputc() 几乎等价。除了其能够被实现作为一个宏，对 stream 多次求值
+ putchar() 等价于 `putc(c, stdout)`。也就是，将字符 c 写入到标准输出流中

```c
int fputc(int c, FILE *stream);
int putc(int c, FILE *stream);
int putchar(int c);
```

+ 参数
	+ c：要打印的字符
	+ strean：流
+ 返回值
	+ 成功：返回打印 unsigned char 的整型值
	+ 失败：EOF

### 5.3  fputs() 和 puts()

+ fputs() 将字符串 s 写入流，不包含其终止符 ('\0')。
+ puts() 将字符串 s 及一个换行符写入标准输出 (stdout)。

```C
int fputs(const char *restrict s, FILE *restrict stream);
int puts(const char *s);
```

+ 参数
	+ s：打印的字符串
	+ stream：流
+ 返回值
	+ 成功：非负数字
	+ 失败：EOF

>[!note]
>puts 总会在要打印的字符串后添加一个新的尾随换行符

### 5.4  fwrite()

+ 函数 fwrite() 从 ptr 指定的位置获取数据，将 n 个数据项写入 stream 指向的流中，每个数据项长度为 size 字节。

```C
size_t fwrite(size_t size, size_t n;
                    const void ptr[restrict size * n],
                    size_t size, size_t n,
                    FILE *restrict stream);
```

+ 参数
	+ ptr：字符串
	+ size：数据项长度
	+ n：数据项数量
	+ stream：流
+ 返回值
	+ 写入流的数据项的数目

## 6  文件读取操作

## 7  系统调用

```C
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
```

```C
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```

## 8  补充

### 8.1  缓冲区刷新函数：fflush()

功能：

+ 刷新 stream
+ 函数 fflush 强制在所给的输出流或更新流 stream 上，写入在用户空间缓冲的所有数据，使用流的底层写功能函数。流的打开状态不受影响。

```c
#include <stdio.h>

       int fflush(FILE *stream);
```

+ 参数
	+ stream
		+ stdout：刷新输出缓存区
		+ NULL：刷新所有流
+ 返回值
	+ 成功，0
	+ 失败，`EOF`，且设置错误标识符`errno`

> [!bug]
> 其参数可以为`stdout`，也可以为文件指针，但不可以是`stdin`，可能会发生未知错误

### 8.2  格式控制符

|格式字符|意义|
|---|---|
|a, A|以十六进制形式输出浮点数(C99 新增)。<br><br>实例 printf("pi=%a\n", 3.14); 输出 **pi=0x1.91eb86p+1**。|
|d|以十进制形式输出带符号整数(正数不输出符号)|
|o|以八进制形式输出无符号整数(不输出前缀0)|
|x,X|以十六进制形式输出无符号整数(不输出前缀Ox)|
|u|以十进制形式输出无符号整数|
|f|以小数形式输出单、双精度实数|
|e,E|以指数形式输出单、双精度实数|
|g,G|以%f或%e中较短的输出宽度输出单、双精度实数|
|c|输出单个字符|
|s|输出字符串|
|p|输出指针地址|
|lu|32位无符号整数|
|llu|64位无符号整数|

| flags（标识） | 描述                                                                                                                                                                            |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| -         | 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。                                                                                                                                           |
| +         | 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。                                                                                                                     |
| 空格        | 如果没有写入任何符号，则在该值前面插入一个空格。                                                                                                                                                      |
| #         | - 与 o、x 或 X 说明符一起使用时，非零值前面会分别显示 0、0x 或 0X。  <br>- 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点。  <br>- 与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 |
| 0         | 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。                                                                                                                               |

|width（宽度）|描述|
|---|---|
|(number)|要输出的字符的最小数目。如果输出的值短于该数，结果会用空格填充。如果输出的值长于该数，结果不会被截断。|
|*|宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。
|

| .precision（精度） | 描述                                                                                                                                                                                                                                                                                                   |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| .number        | 对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。  <br>- 对于 e、E 和 f 说明符：要在小数点后输出的小数位数。  <br>- 对于 g 和 G 说明符：要输出的最大有效位数。  <br>- 对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。  <br>- 对于 c 类型：没有任何影响。  <br>- 当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。 |
| .*             | 精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。                                                                                                                                                                                                                                                        |

| length（长度） | 描述                  | 适用                                                  |
| ---------- | ------------------- | --------------------------------------------------- |
| h          | 参数被解释为短整型或无符号短整型    | 整数说明符：i、d、o、u、x 和 X                                 |
| l          | 参数被解释为长整型或无符号长整型，适用 | 整数说明符（i、d、o、u、x 和 X）及字符说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 |
| L          | 参数被解释为长双精度型         | 仅适用于浮点数说明符：e、E、f、g 和 G                              |
