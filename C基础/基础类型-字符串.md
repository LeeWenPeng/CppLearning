## 1  字符串

- 0 个或多个 " 字符 " 组成的有序序列
- **字符串必须要有 `\0` **

## 2  特点

```C++
// 字符数组，存储字符串变量，结尾会自动添加 \0
char s[5] = {'1', '2', '3', '4'}; 

// 字符数组，存储的不是字符串，因为结尾并非 \0
char s2[5] = {'1', '2', '3', '4', '5'}; 
```

- 字符串变量一定是字符数组，但字符数组不一定是字符串变量

## 3  字符串常量

- 用 `""` 括起来的字符串为字符串常量
- 最后一位是字符串结束符 `\0`

```C
// 1 字符串常量
// "abcd" <=> 'a' 'b' 'c' 'd' '\0'

// 2 字符串常量，不可修改
char* s2 = "bbbb";
const char* s3 = "cccc";
```

## 4  字符串变量

- C 语言中，字符串是以 " 字符数组 " 的形式存储的

```C++
// 存储字符串变量，可修改
char s[] = "aaaa";
```

## 5  字符串处理函数

### 5.1  字符串有效长度：strlen

- 返回字符串 s 的长度，不计入 `\0
- 遇到 `\0` 结束

```c
#include <string.h>

size_t strlen(const char *s);
```

- 参数 s：字符串 s
- 返回值 s：指向字符串的字节数，不计算 `\0`

#### 5.1.1  strlen 和 sizeof

- sizeof(str)：计算 str 所占内存大小
- strlen(str)：计算 str 字面值大小（有效长度）

```cpp
int str[5] = "ab\0cd";

printf("%d, %d\n", sizeof(str), strlen(str)); // 5 2
```

### 5.2  字符串复制函数： strcpy 和 strncpy

将非空字节从 src 指向的字符串复制到 dst 指向的数组中。

- 如果源地址的非空字节太少，无法填充目标地址，则函数会在目标地址后添加空字节。
- 如果目标缓冲区受其大小限制，不足以容纳副本，则生成的字符序列将被截断。

```cpp
#include <string.h>
char *strcpy(char *restrict dst, const char *restrict src);
       
char *strncpy(char dst[restrict dsize], const char *restrict src, size_t dsize);
```

- 参数
	- dst：目标缓冲区
	- src：源字符串
	- dsize：要复制的字符串的长度
		- 如果 dsize > sizeof(src)：则在后面填充 0
		- 如果 dsize < sizeof(src)：则截断 src
- 返回值
	- dst

#### 5.2.1  补充

- strcpy：遇到 `\0` 结束，会包含 `\0`，也就是将 `\0` 也复制到目标地址
- strncpy：会自动添加 `\0` 在最后，因此最好 `dsize <= sizeof(dst) -1`

### 5.3  字符串比较：strcmp、strncmp

- strcmp() 函数比较两个字符串 s1 和 s2。
- 比较使用无符号字符进行。
- strncmp() 函数类似，但它只比较 s1 和 s2 的前（最多）n 个字节。
- 二者都是

```c
#include <string.h>

int strcmp(const char *s1, const char *s2);
int strncmp(const char s1[n], const char s2[n], size_t n);
```

- 参数
	- s1: 字符串
	- s2：字符串
	- n：限制比较的范围，为 `[0, min(sizeof(s), n))`
- 返回值：返回一个整数，表示比较结果，如下所示：
	- 如果 s1 和 s2 相等，则返回 0；
	- 如果 s1 小于 s2，则返回负值；
	- 如果 s1 大于 s2，则返回正值。

### 5.4  字符串比较 2：strcasecmp、 strncasecmp

- 功能和上述类似

### 5.5  字符串拼接：strcat、strncat

- 此函数从 src 指向的数组中追加最多 ssize 个非空字节，后跟一个空字符，到 dst 指向的字符串的末尾。
- dst 必须指向一个包含在足够大的缓冲区中的字符串，也就是说，缓冲区大小必须至少为 strlen(dst) + strnlen(src, ssize) + 1。

```c
#include <string.h>
char *strcat(char *restrict dst, const char *restrict src);
char *strncat(char *restrict dst, const char src[restrict ssize], size_t ssize);
```

- 参数
	- dst：目标缓冲区
	- stc：源字符串
	- ssize：要复制的字符串的长度
- 返回值：dst

### 5.6  字符串转换函数：atoi、atol、atoll

- 将 nptr 指向的字符串的起始部分转换为 int 、long 和 long long 。
- 其行为和 strtol(nptr, NULL, 10); 相同，但不检测错误

```c
#include <stdlib.h>

int atoi(const char *nptr);
long atol(const char *nptr);
long long atoll(const char *nptr);
```

- 参数 nptr：字符串
- 返回值
	- 成功: 转换值
	- 失败：0

### 5.7  查找字符：strchr

`strchr` 函数用于在字符串中**首次**出现指定字符的位置。

```c
#include <string.h>

char *strchr(const char *s, int c);
```

- 参数：
	- s：要被检索的字符串
	- c：要查找的字符。虽然参数类型是 `int`，但在传入时会被转换为 `char`。通常你直接传入一个字符（如 `'a'`）即可。
- 返回值
	-   **查找成功**：返回一个指向字符串 `str` 中**第一次**出现字符 `character` 的**指针**。
	-   **查找失败**：如果字符串中不存在该字符，则返回**空指针（`NULL`）**。

**如何计算字符的索引（位置）？**
通过指针运算可以轻松得到字符在字符串中的索引（从 0 开始）：
`int index = result - str;` // 结果指针 - 字符串起始地址 = 偏移量

**查找最后一次出现？**
`strchr` 的 " 姐妹函数 " 是 `strrchr`（最后一个 `r` 代表 `reverse`），它用于查找字符在字符串中**最后一次**出现的位置。

### 5.8  查找字符串：strstr

`strstr` 函数用于在一个字符串（ haystack ）中**首次**出现另一个子字符串（ needle ）的位置。

```c
# 5.8  #include <string.h>

char *strstr(const char *haystack, const char *needle);
```

- 参数
	-   `haystack`: 被检索的主字符串。
	-   `needle`: 要查找的子字符串。
- 返回值
	-   **查找成功**：返回一个指向 `haystack` 中第一次出现整个 `needle` 子字符串的**指针**。
	-   **查找失败**：如果 `haystack` 中不包含 `needle`，则返回**空指针（`NULL`）**。
	-   **特殊情况**：如果 `needle` 是空字符串（`""`），则函数返回 `haystack` 的起始地址。

> [!NOTE] strstr 大小写敏感
`strstr` 是**大小写敏感**的。`"Hello"` 和 `"hello"` 被认为是不同的字符串。如果需要不区分大小写的查找，需要使用其他方法，例如 POSIX 的 `strcasestr` 函数（非标准 C），或者自己实现一个循环比较。
