## 1  map/multimap 容器

map 的特点：

1. map 中所有的值都是 pair
   1. pair 是 `<key, value>` 键值对，其中 key 称为 键值， value 称为 实值
2. 插入 map 的 pair 会自动根据其==键值==排序

   类似于 set 容器，或者说就是升级版的 set 容器

   > 所以与 Set 容器相同的点是：
   > 
   > 3. map/multimap 都是关联式容器，底层都是二叉树
   > 4. map 和 multimap 的区别类似于 set 和 multiset 的区别：
   > 5. map 不允许有重复的键值元素
   > 6. multimap 允许有重复的键值元素

### 1.1  构造与赋值

![image-20231008103302658](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231008103302658.png)

> 构造和赋值也和 set 容器类似
>
> 1. 默认无参构造，后续插值使用 `insert` 函数，将新的 pair 键值对插入到 map 容器中
> 2. 拷贝构造
> 
> 赋值：使用重载的 = 运算符进行容器对象的赋值

### 1.2  大小和交换

![image-20231008103630931](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231008103630931.png)

> 和 set 容器基本一样

### 1.3  插入和删除

![image-20231008103710803](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231008103710803.png)

#### 1.3.1  插入的四种方式

```c++
void test1(){
    // set<People, MyCompare> s1;

    People p1("关羽", 25);
    People p2("张飞", 18);
    People p3("刘备", 37);

    map<int, int> m1;

    // 1
    m1.insert(pair<int, int>(1,20));

    // 2
    m1.insert(make_pair(3, 29));

    // 3
    m1.insert(map<int, int>::value_type(4,8));

    // 4
    m1[6] = 25;

    printMap(m1);
    //1 : 20
    //3 : 29
    //4 : 8
    //6 : 25
}
```

> 前两种方式没有什么特殊的，都是==先构造一个 pair 键值对，然后插入进去==
>
>
>
> 第三种方法是根据 map 容器中的值类型 `value_type` ，是通过一个间接的角度构造一个 pair 键值对
>
>
>
> 最后一个方法是通过重载的 `[]` 运算符，这个地方是存在一个问题的，重载的 `[]` 运算符功能过于强大：
>
> 1. 可以通过 `[key]` 访问对应 key 的 value
> 2. 可以通过 `[key]` 修改对应 `key` 的 `value`
> 3. 可以插入新的 `<key, value>`
> 
> 换而言之，==通过最后一种方法进行插入时，如果新的键值与 map 容器中已有的键值相等，则不会插入失败，而是修改掉已有的键值对应的实值==
>
> 同时，如果==通过 `[key]` 访问到了一个不存在的键值，那么 map 容器中会自动插入一个新的键值对，其中键值为这个不存在的键值，实值为 0==

#### 1.3.2  删除的三种方式

1. 通过迭代器删除单独某个键值对
2. 通过迭代器删除一个范围内的键值对
3. 通过键值删除单独某个键值对

### 1.4  查找和统计

![image-20231008134543461](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231008134543461.png)

> 和 set 容器一样

### 1.5  排序

> 和 set 容器一样，提供一个比较器仿函数，设置比较规则
