## 1  常用算法

由头文件 `<algorithm>`、`<functional>`、`<numeric>` 三部分组成

- `<algorithm>`
  - 所有 STL 头文件最大的一个
  - 基本所有基础算法都在这个头文件中

- `<functional>`
  - 内建仿函数
- `<numetric>`
  - 定义了一些模板类，用于声明函数对象

## 2  遍历算法

头文件

```cpp
#include <algorithm>
```

### 2.1  for_each

```c++
    for_each(IIter, IIter, Funct)
```

参数

- 起始迭代器
- 结束迭代器
- 函数或仿函数对象，如果是仿函数的话，记得带上 `()`

示例

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
class ForEach{
public:
    bool operator()(int v){
        cout << v <<" ";
        return v;
    }
};

bool ForEach_1(int v){
    cout << v << " ";
    return v;
}

void test1(){

    vector<int> v1;

    for (int i = 0; i!=10; ++i) {
        v1.push_back(i) ;
    }

    // 仿函数 需要传递的是仿函数对象，需要加()，创建一个匿名函数
    for_each(v1.begin(), v1.end(), ForEach() ); // 0 1 2 3 4 5 6 7 8 9 
    cout << endl;
    
    // 普通函数，传递函数名
    for_each(v1.begin(), v1.end(), ForEach_1); // 0 1 2 3 4 5 6 7 8 9 

}  

int main(){
    test1();
    return 0;
}
```

### 2.2  transform

```c++
transform(IIter, IIter, OIter, UnaryOperation)
```

参数

- 源容器起始迭代器
- 源容器结束迭代器
- 目标容器起始迭代器
- 函数或仿函数对象
	- 在搬运过程中，对源容器中的数据做一层处理
	- 如果源容器中的数据为参数 `X`，那么，目标容器中获取的数据就为 `f

示例

```c++

```

> 注意事项：搬运时，目标容器需要有内存空间

## 3  常用查找算法

![image-20231011152706092](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231011152706092.png)

### 3.1  find

作用：查找元素，返回迭代器

```c++
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
	 const _Tp& __val)
    {
      // concept requirements
				      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_EqualOpConcept<
		typename iterator_traits<_InputIterator>::value_type, _Tp>)
      __glibcxx_requires_valid_range(__first, __last);
      return std::__find_if(__first, __last,
			    __gnu_cxx::__ops::__iter_equals_val(__val));
    }
```

- 参数
	- 起始迭代器
	- 结束迭代器
	- 值
- 返回值：和输入迭代器类型一样的迭代器

#### 3.1.1  代码原理

1. 循环，从起始迭代器开始，到结束迭代结束
2. 判断循环指针指向的值和提供的值是否相等，相等时中断循环
3. 返回迭代器

> [!important] 代码本质
传入了等值函数的 `find_if` 函数

#### 3.1.2  示例

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

class People{
    public:
    People(string name, int age){
        this->m_name = name;
        this->m_age = age;
    }
	
    // 重载 等值运算符
    bool operator== (const People& p) const{
        if(this->m_age == p.m_age && this->m_name == p.m_name){
            return true;
        }
        return false;
    }
    string m_name;
    int m_age;
};

void test1(){

    vector<People> v2;

    People p1("张三", 18);
    People p2("李四", 20);
    People p3("王五", 20);
    People p4("张飞", 22);

    v2.push_back(p1);
    v2.push_back(p2);
    v2.push_back(p4);
	
    // 这里的 p2 是一个特殊类型
    // find 最后是调用等值运算符 判断 *first == p2
    // 如果不是基础类型的，则无法判断，报错
    // 所以需要在自定义数据类型中重载等值运算符
    vector<People>::iterator it2 = find(v2.begin(), v2.end(), p2);
    if(it2!=v2.end {
        cout << " 找到值为："<<it2->m_name<<" : "<<  it2->m_age << endl;
    }else{
        cout << " 未找到" << endl;
    }

}  

int main(){
    test1();
    return 0;
}
```

### 3.2  find_if

![image-20231015151224412](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231015151224412.png)

> find 函数的底层，最后需要提供一个谓词，用作查找条件
>
> find 函数的最后一个参数是一个变量，但其本质是，使用了 find_if 函数，并给提供一个判等的谓词
>
> 谓词可以是函数名，也可以是仿函数对象

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

class People{
    public:
    People(string name, int age){
        this->m_name = name;
        this->m_age = age;
    }
    string m_name;
    int m_age;
};

class PeopleGreater20{
    public:
    bool operator()(People p){
        return p.m_age>20;
    }
};

void test1(){

    vector<People> v2;

    People p1("张三", 18);
    People p2("李四", 20);
    People p3("王五", 20);
    People p4("张飞", 22);

    v2.push_back(p1);
    v2.push_back(p2);
    v2.push_back(p4);

    vector<People>::iterator it2 = find_if(v2.begin(), v2.end(), PeopleGreater20 ;
    //vector<People>::iterator it2 = find_if(v2.begin(), v2.end(), PeopleGreater20Function);
    if(it2!=v2.end {
        cout << " 找到值为："<<it2->m_name<<" : "<<  it2->m_age << endl;
    }else{
        cout << " 未找到" << endl;
    }

}  

int main(){
    test1();
    return 0;
}
```

### 3.3  adjacent_find

查找相邻重复元素

![image-20231015152034745](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231015152034745.png)

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

class People{
    public:
    People(string name, int age){
        this->m_name = name;
        this->m_age = age;
    }
    bool operator==(People &p){
        if(this->m_age == p.m_age && this->m_name == p.m_name) return true;
        return false;
    }
    string m_name;
    int m_age;
};

void test1(){

    vector<People> v2;

    People p1("张三", 18);
    People p2("王五", 20);
    People p3("王五", 20);
    People p4("张飞", 22);

    v2.push_back(p1);
    v2.push_back(p2);
    v2.push_back(p3);

    vector<People>::iterator it2 = adjacent_find(v2.begin(), v2.end ;
    if(it2!=v2.end {
        cout << " 找到值为："<<it2->m_name<<" : "<<  it2->m_age << endl;
    }else{
        cout << " 未找到" << endl;
    }

}  

int main(){
    test1();
    return 0;
}
```

> - 如果是自定义数据，在使用算法库中的算法时，需要注意的是，是否需要进行一些比如元素之间的比较操作，这些自定义数据无法使用默认的运算符进行的操作
> - 如果有，则需要在自定义数据类型中对相关的运算符做重载操作
> - 比如，在 find 函数和 adjacent_find 函数中，如果要遍历的数组是自定义数据类型数据的数组，则需要进行等值判断操作，则需要在自定义数据类型中对等值运算符做一个重载

### 3.4  binary_search

查找指定元素是否存在

![image-20231015152706287](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231015152706287.png)

> - 之前的 find 函数，返回的是迭代器，而，这个二分查找算法返回值为 `bool` 类型
> - `binary_search` 只能在==有序序列==中使用
>   - ==这个有序的意思不是升序或者降序，而是，所有符合 `elem < val` 的 `elem` 都排在 `val` 前==
> 	- 或者说降序序列反而完全不可以使用

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

bool myCompare(int a, int b){
    return a>b;
}

void test1(){

    vector<int> v1;
    for(int i=0;i<10;++i){
        v1.push_back ;
    }

    bool res = binary_search(v1.begin(), v1.end(), 2);// 查找到
    if(res){
        cout << " 查找到元素" << endl; 
    }else{
        cout << "未查找到元素" << endl;
    }

    sort(v1.begin(), v1.end(), myCompare); // 9 8 7 6 5 4 3 2 1 0
    for(vector<int>::iterator it=v1.begin(); it!=v1.end();++it){
        cout << *it<<" ";
    }
    cout << endl;
    res = binary_search(v1.begin(), v1.end(), 10);// 未查找到
    if(res){
        cout << " 查找到元素" << endl;
    }else{
        cout << "未查找到元素" << endl; 
    }

    v1.push_back(10); // 9 8 7 6 5 4 3 2 1 0 10
    for(vector<int>::iterator it=v1.begin(); it!=v1.end();++it){
        cout << *it<<" ";
    }
    cout << endl;
    res = binary_search(v1.begin(), v1.end(), 10);// 查找到
    if(res){
        cout << " 查找到元素" << endl; 
    }else{
        cout << "未查找到元素" << endl;
    }
}  

int main(){
    test1();
    return 0;
}
```

> 根据上述代码，显而易见的是，这个有序是只，分块有序：
>
> - 在使用 binary_search 时，序列会被需要查找的值分为三块
> - before val after
> - 这个有序就是指，
>   - before 序列中所有的值都小于 val
>   - after 序列中所有的值都大于 val
> - 也就是在块级上，是有序，且是升序的

### 3.5  count

![image-20231015154012145](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231015154012145.png)

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

class People{
    public:
    People(string name, int age){
        this->m_name = name;
        this->m_age = age;
    }
    // 注意，这里的参数需要是常参数 const 不可以少
    bool operator==(const People &p){
        return (this->m_age == p.m_age );
    }
    string m_name;
    int m_age;
};

void test1(){

    vector<People> v2;

    People p1("张三", 18);
    People p2("王五", 20);
    People p3("王五", 20);
    People p4("张飞", 22);

    v2.push_back(p1);
    v2.push_back(p2);
    v2.push_back(p3);

    int num = count(v2.begin(), v2.end(), p3);

    cout << p3.m_name <<"的个数为：" << num << endl;

}  

int main(){
    test1();
    return 0;
}
```

> count 源代码：
>
> ```c++
>   template<typename _InputIterator, typename _Tp>
>     inline typename iterator_traits<_InputIterator>::difference_type
>     count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
>     {
>       // concept requirements
>       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>       __glibcxx_function_requires(_EqualOpConcept<
> 	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
>       __glibcxx_requires_valid_range(__first, __last);
> 
>       return std::__count_if(__first, __last,
> 			     __gnu_cxx::__ops::__iter_equals_val(__value));
>     }
> ```
>
> - 注意，第三个参数的参数类型带着 `const`
>   - 这也就是为什么，如果重载的等值运算符参数如果不带 `const` 会报错的原因了

### 3.6  count_if

按条件统计元素个数

![image-20231016072643304](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016072643304.png)

## 4  常用排序算法

### 4.1  sort

![image-20231016101642325](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016101642325.png)

> 默认升序，通过指定比较器的方式可以修改成降序排列

### 4.2  random_shuffle

将序列中的元素顺序打乱

![image-20231016101852351](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016101852351.png)

> 源代码：
>
> ```c++
>   template<typename _RandomAccessIterator>
>     inline void
>     random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
>     {
>       // concept requirements
>       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
> 	    _RandomAccessIterator>)
>       __glibcxx_requires_valid_range(__first, __last);
> 
>       if (__first != __last)
> 	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
> 	  {
> 	    // XXX rand() % N is not uniformly distributed
> 	    _RandomAccessIterator __j = __first
> 					+ std::rand() % ((__i - __first) + 1);
> 	    if (__i != __j)
> 	      std::iter_swap(__i, __j);
> 	  }
>     }
> ```
>
> 底层使用了 rand() 函数，所以也需要指定时间种子
>
> 原理就是：
>
> - 挨个遍历，当指针指向一个下标 i 的数据时
> - 在 $[i+1, v.size()-1)$ 的范围内，随机出一个新的下标 j
> - 交换 v[i] 与 v[j]

```c++
#include <algorithm>
#include <iostream>
#include <stdlib.h>
#include <vector>
using namespace std;

void test1(){

    vector<int> v1;

    for(int i = 0; i!=10; ++i){
        v1.push_back ;
    }
    srand((unsigned)time_t(NULL));
    random_shuffle(v1.begin(), v1.end ;

    for(vector<int>::iterator it = v1.begin(); it!=v1.end();++it){
        cout << *it<<" ";
    }
    cout << endl;

}  

int main(){
    test1();
    return 0;
}
```

### 4.3  merge

将两个容器中的数据合并，并复制给目标容器

![image-20231016102524877](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016102524877.png)

> 源代码：
>
> ```c++
>   template<typename _InputIterator1, typename _InputIterator2,
> 	   typename _OutputIterator>
>     inline _OutputIterator
>     merge(_InputIterator1 __first1, _InputIterator1 __last1,
> 	  _InputIterator2 __first2, _InputIterator2 __last2,
> 	  _OutputIterator __result)
>     {
>       // concept requirements
>       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
> 	    typename iterator_traits<_InputIterator1>::value_type>)
>       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
> 	    typename iterator_traits<_InputIterator2>::value_type>)
>       __glibcxx_function_requires(_LessThanOpConcept<
> 	    typename iterator_traits<_InputIterator2>::value_type,
> 	    typename iterator_traits<_InputIterator1>::value_type>)	
>       __glibcxx_requires_sorted_set(__first1, __last1, __first2);
>       __glibcxx_requires_sorted_set(__first2, __last2, __first1);
>       __glibcxx_requires_irreflexive2(__first1, __last1);
>       __glibcxx_requires_irreflexive2(__first2, __last2);
> 
>       return _GLIBCXX_STD_A::__merge(__first1, __last1,
> 				     __first2, __last2, __result,
> 				     __gnu_cxx::__ops::__iter_less_iter ;
>     }
> ```
>
> 核心代码：
>
> ```c++
> return _GLIBCXX_STD_A::__merge(__first1, __last1,
> 				     __first2, __last2, __result,
> 				     __gnu_cxx::__ops::__iter_less_iter ;
> ```
>
> 调用了 `__iter_less_iter()` 函数，合并时会对两个容器中的数据进行比较，优先插入更小的值
>
> 所以要求==两个容器在合并时需要有序==
>
> 但，==无序的列表合并并不会出错，只不过合并出来的结果仍然是无序的==

```c++
#include <algorithm>
#include <iostream>
#include <stdlib.h>
#include <vector>
using namespace std;

void test1(){

    vector<int> v1;
    vector<int> v2;
    vector<int>v3;

    for(int i = 0; i!=10; ++i){
        v1.push_back ;
        v2.push_back(i+1);
    }

    v3.resize(v1.size()+v2.size ;

    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin ;
   
    for(vector<int>::iterator it = v3.begin(); it!=v3.end();++it){
        cout << *it<<" ";
    }
    cout << endl;

}  

int main(){
    test1();
    return 0;
}
```

> 需要提前给目标容器分配内存空间，空间大小为两个需要合并的容器的内存空间大小

#### 4.3.1  补充

merge 算法是可以提供比较器的

```c++
__merge(_InputIterator1 __first1, _InputIterator1 __last1,
	    _InputIterator2 __first2, _InputIterator2 __last2,
	    _OutputIterator __result, _Compare __comp)
```

比如想要**降序合并时**

```c++
#include <algorithm>
#include <iostream>
#include <stdlib.h>
#include <vector>
using namespace std;

bool myCompare(int a, int b){
    return a>b;
}
void test1(){

    vector<int> v1;
    vector<int> v2;
    vector<int>v3;

    for(int i = 0; i!=10; ++i){
        v1.push_back ;
        v2.push_back(i+1);
    }

    reverse(v2.begin(), v2.end ;
    reverse(v1.begin(), v1.end ;

    v3.resize(v1.size()+v2.size ;
	
    // 最后一个参数是比较器
    merge(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin(), myCompare);
   
    for(vector<int>::iterator it = v3.begin(); it!=v3.end();++it){
        cout << *it<<" ";
    }
    cout << endl;

}  

int main(){
    test1();
    return 0;
}
```

### 4.4  reverse

将容器中元素序列翻转

![image-20231016103557734](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016103557734.png)

## 5  常用的拷贝和替换算法

### 5.1  copy

将容器中指定范围内的元素拷贝的另一个容器中

![image-20231016103733022](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016103733022.png)

返回目标容器的结束迭代器，也就是 `dest.end()`

#### 5.1.1  补充：merge

merge 算法的底层也使用了 copy 算法

```c++
template<typename _InputIterator1, typename _InputIterator2,
	   typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
	    _InputIterator2 __first2, _InputIterator2 __last2,
	    _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
	{
	  if (__comp(__first2, __first1))
	    {
	      *__result = *__first2;
	      ++__first2;
	    }
	  else
	    {
	      *__result = *__first1;
	      ++__first1;
	    }
	  ++__result;
	}
      return std::copy(__first2, __last2,
		       std::copy(__first1, __last1, __result));
    }
```

可以看到 merge 函数的函数体内，代码分为两部分：

1. 在两个容器都没有遍历完时，将两个容器中的数据，按照顺序合并
2. 在至少其中一个容器结束遍历后，将剩余部分的数据 copy 到 result 容器中

   ```c++
   std::copy(__first2, __last2,
   		       std::copy(__first1, __last1, __result));
   ```

   最后返回目标容器的结束迭代器，其实也是通过 copy() 返回的

### 5.2  replace

![image-20231016123646585](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016123646585.png)

> 源函数：
>
> ```c++
>   template<typename _ForwardIterator, typename _Tp>
>     void
>     replace(_ForwardIterator __first, _ForwardIterator __last,
> 	    const _Tp& __old_value, const _Tp& __new_value)
>     {
>       // concept requirements
>       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
> 				  _ForwardIterator>)
>       __glibcxx_function_requires(_EqualOpConcept<
> 	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
>       __glibcxx_function_requires(_ConvertibleConcept<_Tp,
> 	    typename iterator_traits<_ForwardIterator>::value_type>)
>       __glibcxx_requires_valid_range(__first, __last);
> 
>       for (; __first != __last; ++__first)
> 	if (*__first == __old_value)
> 	  *__first = __new_value;
>     }
> ```
>
> 核心代码：
>
> ```c++
>       for (; __first != __last; ++__first)
> 	if (*__first == __old_value)
> 	  *__first = __new_value;
> ```
>
> 遍历容器中的数据，遍历到对应值时，将对应值替换成新值，无返回值

```c++
#include <algorithm>
#include <iostream>
#include <stdlib.h>
#include <vector>
using namespace std;

void test1(){

    vector<int> v2;

    for(int i = 0; i!=10; ++i){
        v2.push_back(i+1);
    }
    v2.push_back(20);
    v2.push_back(30);
    v2.push_back(40);
    v2.push_back(50);

    replace(v2.begin(), v2.end(), 20, 1000);
    
    for(vector<int>::iterator it = v2.begin(); it!=v2.end();++it){
        cout << *it<<" ";
    }
    cout << endl;
}  

int main(){
    test1();
    return 0;
}
```

### 5.3  repalce_if

![image-20231016124052262](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016124052262.png)

> repalce 函数其实就相当于 repalce_if 函数中的谓词为等值谓词
>
> 用 replace_if 实现 replace
>
> ```c++
> #include <algorithm>
> #include <iostream>
> #include <stdlib.h>
> #include <vector>
> using namespace std;
> 
> class MyCompare{
> 
>     public:
> 
>     MyCompare(int num){
>         this->m_num = num;
>     }
> 
>     bool operator()(int val){
>         return this->m_num == val;
>     }
>     
>     int m_num;
> };
> 
> void test1(){
> 
>     vector<int> v2;
> 
>     for(int i = 0; i!=10; ++i){
>         v2.push_back(i+1);
>     }
>     v2.push_back(20);
>     v2.push_back(30);
>     v2.push_back(40);
>     v2.push_back(50);
> 
>     replace_if(v2.begin(), v2.end(), MyCompare(20), 1000);
>     
>     for(vector<int>::iterator it = v2.begin(); it!=v2.end();++it){
>         cout << *it<<" ";
>     }
>     cout << endl;
> }  
> 
> int main(){
>     test1();
>     return 0;
> }
> ```
>
> repalce_if 源函数
>
> ```c++
>   template<typename _ForwardIterator, typename _Predicate, typename _Tp>
>     void
>     replace_if(_ForwardIterator __first, _ForwardIterator __last,
> 	       _Predicate __pred, const _Tp& __new_value)
>     {
>       // concept requirements
>       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
> 				  _ForwardIterator>)
>       __glibcxx_function_requires(_ConvertibleConcept<_Tp,
> 	    typename iterator_traits<_ForwardIterator>::value_type>)
>       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
> 	    typename iterator_traits<_ForwardIterator>::value_type>)
>       __glibcxx_requires_valid_range(__first, __last);
> 
>       for (; __first != __last; ++__first)
> 	if (__pred(*__first))
> 	  *__first = __new_value;
>     }
> ```
>
> 核心代码：
>
> ```c++
>       for (; __first != __last; ++__first)
> 	if (__pred(*__first))
> 	  *__first = __new_value;
> ```
>
> 以谓词为判断条件，将符合谓词的数据做替换，==注意，这里的谓词是一元谓词！==

```c++
#include <algorithm>
#include <iostream>
#include <stdlib.h>
#include <vector>
using namespace std;

class GreaterNum{

    public:

    GreaterNum(int num){
        this->m_num = num;
    }

    bool operator()(int val){
        return this->m_num<val;
    }

    int m_num; 
};

void test1(){

    // 将大于9 的数都替换成9
    vector<int> v2;

    for(int i = 0; i!=10; ++i){
        v2.push_back(i+1);
    }
    v2.push_back(20);
    v2.push_back(30);
    v2.push_back(40);
    v2.push_back(50);

    replace_if(v2.begin(), v2.end(), GreaterNum , 9);
    
    for(vector<int>::iterator it = v2.begin(); it!=v2.end();++it){
        cout << *it<<" ";
    }
    cout << endl;
}  

int main(){
    test1();
    return 0;
}
```

### 5.4  swap

![image-20231016140021217](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016140021217.png)

```c++
#include <algorithm>
#include <any>
#include <iostream>
#include <stdlib.h>
#include <vector>
using namespace std;

class MyPrint{
    public:
    void operator()(int p){
        cout << p << " ";
    }
};

void test1(){

    // 将大于9 的数都替换成9

    vector<int> v1;
    vector<int> v2;

    for(int i = 0; i!=10; ++i){
        v1.push_back ;
        v2.push_back(i+100);
    }
    swap(v1, v2);
    for_each(v1.begin(), v1.end(), MyPrint ;
    cout << endl;
    for_each(v2.begin(), v2.end(), MyPrint ;
}  

int main(){
    test1();
    return 0;
}
```

> 交换的时候，也进行内存空间的互换

## 6  常用算术生成算法

算术生成算法属于小型算法，使用时应包含头文件 `#include<numeric>`

### 6.1  accumulate

![image-20231016140615606](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016140615606.png)

> 源函数：
>
> ```c++\
>   template<typename _InputIterator, typename _Tp>
>     inline _Tp
>     accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
>     {
>       // concept requirements
>       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>       __glibcxx_requires_valid_range(__first, __last);
> 
>       for (; __first != __last; ++__first)
> 	__init = __init + *__first;
>       return __init;
>     }
> ```
>
> 返回类型根据输入的第三个参数 `__init` 来设置

```c++
#include <iostream>
#include <numeric>
#include <vector>
using namespace std;

void test1(){

    // 将大于9 的数都替换成9

    vector<int> v1;
    vector<int> v2;

    for(int i = 0; i!=10; ++i){
        v1.push_back ;
    }
    int a = accumulate(v1.begin(), v1.end(), 0);
    cout << a << endl; // 45
}  

int main(){
    test1();
    return 0;
}
```

### 6.2  fill

将指定区间内的元素，替换成填充元素

![image-20231016141001249](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016141001249.png)

> 填充是只针对于内存上的填充，而不是针对于容器。
>
> 也就是在迭代器指向的内存上填充上填充元素，无论对应内存上是否已经存在数据。
>
> 可以看成是 n 版的 replace 函数

```c++
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
using namespace std;

class MyPrint{
    public:
    void operator()(int &p){
        cout << p << " ";
    }
};
void test1(){

    // 将大于9 的数都替换成9

    vector<int> v1;
    vector<int> v2;

    for(int i = 0; i!=10; ++i){
        v1.push_back ;
    }
    fill(v1.begin(), v1.end(), 10);
    for_each(v1.begin(), v1.end(), MyPrint ;
}

int main(){
    test1();
    return 0;
}
```

## 7  常用集合算法

### 7.1  set_intersection

![image-20231016145616394](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016145616394.png)

> 找到两个容器中存储数据的交集，并复制到目标容器中
>
> 源函数 1：
>
> ```c++
> template<typename _InputIterator1, typename _InputIterator2,
> 	   typename _OutputIterator>
>     inline _OutputIterator
>     set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
> 		     _InputIterator2 __first2, _InputIterator2 __last2,
> 		     _OutputIterator __result)
>     {
>       // concept requirements
>       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
> 	    typename iterator_traits<_InputIterator1>::value_type>)
>       __glibcxx_function_requires(_LessThanOpConcept<
> 	    typename iterator_traits<_InputIterator1>::value_type,
> 	    typename iterator_traits<_InputIterator2>::value_type>)
>       __glibcxx_function_requires(_LessThanOpConcept<
> 	    typename iterator_traits<_InputIterator2>::value_type,
> 	    typename iterator_traits<_InputIterator1>::value_type>)
>       __glibcxx_requires_sorted_set(__first1, __last1, __first2);
>       __glibcxx_requires_sorted_set(__first2, __last2, __first1);
>       __glibcxx_requires_irreflexive2(__first1, __last1);
>       __glibcxx_requires_irreflexive2(__first2, __last2);
> 
>       return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
> 				     __first2, __last2, __result,
> 				     __gnu_cxx::__ops::__iter_less_iter ;
>     }
> ```
>
> 核心代码：
>
> ```c++
>  return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
> 				     __first2, __last2, __result,
> 				     __gnu_cxx::__ops::__iter_less_iter ;
> ```
>
>
>
> - 调用了源函数 2
> - 提供了一个比较器为：`__gnu_cxx::__ops::__iter_less_iter()`
> 
> 源函数 2：是源函数 1 的底层函数
>
> ```c++
>   template<typename _InputIterator1, typename _InputIterator2,
> 	   typename _OutputIterator,
> 	   typename _Compare>
>     _OutputIterator
>     __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
> 		       _InputIterator2 __first2, _InputIterator2 __last2,
> 		       _OutputIterator __result, _Compare __comp)
>     {
>       while (__first1 != __last1 && __first2 != __last2)
> 	if (__comp(__first1, __first2))
> 	  ++__first1;
> 	else if (__comp(__first2, __first1))
> 	  ++__first2;
> 	else
> 	  {
> 	    *__result = *__first1;
> 	    ++__first1;
> 	    ++__first2;
> 	    ++__result;
> 	  }
>       return __result;
>     }
> ```
>
> 可以看出，
>
> - 过程
> 
>   1. 代码中是使用双指针
>   2. 指针分别指向两个容器
>   3. 对指针指向的数据比大小
>   4. 将相等数据复制给目标容器
> 
> - 返回值：
> 
>   - 这里返回的迭代器是结果迭代器最后一个元素的位置
> 
>   - `__result <= end()`
> 
> - 代码结果：
> 
>   - 如果求交集的两个交集中的数据，本身就是升序的，则如果使用默认的比较器，结果容器中的数据也应该是升序的

```c++
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
using namespace std;

class MyPrint{
    public:
    void operator()(int p){
        cout << p << " ";
    }
};
void test1(){

    // 将大于9 的数都替换成9

    vector<int> v1;
    vector<int> v2;
    vector<int> v3;

    for(int i = 0; i!=10; ++i){
        v1.push_back ;
        v2.push_back(i+5);
    }
    v3.resize(min(v1.size(), v2.size );
    for_each(v1.begin(), v1.end(), MyPrint ;
    cout << endl;
    for_each(v2.begin(), v2.end(), MyPrint ;
    cout << endl;
    vector<int>::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin ;
    // 注意，这里的结束迭代器是 set_intersection 返回的迭代器
    // 能减少遍历次数
    for_each(v3.begin(), itEnd, MyPrint ;
}

int main(){
    test1();
    return 0;
}
```

> 1. 目标容器需要赋予内存空间
> 2. 极端情况，一个容器为另一个容器的子集，也就是说，目标容器最多需要 `min(v1.size(), v2.size ` 大小的内存空间

### 7.2  set_union

求两个容器的并集

![image-20231016151439645](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016151439645.png)

> 源函数：默认比较器为 `__gnu_cxx::__ops::__iter_less_iter()`
>
> ```c++
>   template<typename _InputIterator1, typename _InputIterator2,
> 	   typename _OutputIterator,
> 	   typename _Compare>
>     _OutputIterator
>     __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
> 		_InputIterator2 __first2, _InputIterator2 __last2,
> 		_OutputIterator __result, _Compare __comp)
>     {
>       while (__first1 != __last1 && __first2 != __last2)
> 	{
> 	  if (__comp(__first1, __first2))
> 	    {
> 	      *__result = *__first1;
> 	      ++__first1;
> 	    }
> 	  else if (__comp(__first2, __first1))
> 	    {
> 	      *__result = *__first2;
> 	      ++__first2;
> 	    }
> 	  else
> 	    {
> 	      *__result = *__first1;
> 	      ++__first1;
> 	      ++__first2;
> 	    }
> 	  ++__result;
> 	}
>       return std::copy(__first2, __last2,
> 		       std::copy(__first1, __last1, __result));
>     }
> ```
>
> - 双指针遍历，复制
> - 两个容器对应相同的元素只复制一个
> - 返回指针为目标容器中最后元素的下一个位置迭代器

```c++
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
using namespace std;

class MyPrint{
    public:
    void operator()(int p){
        cout << p << " ";
    }
};
void test1(){

    // 将大于9 的数都替换成9

    vector<int> v1;
    vector<int> v2;
    vector<int> v3;

    for(int i = 0; i!=10; ++i){
        v1.push_back ;
        v2.push_back(i+5);
    }
    v1.push_back(30);
    v1.push_back(30);
    v1.push_back(30);
    v2.push_back(30);
    v2.push_back(30);
    v2.push_back(30);
    v3.resize((v1.size()+ v2.size );
    for_each(v1.begin(), v1.end(), MyPrint ;//0 1 2 3 4 5 6 7 8 9 30 30 30 
    cout << endl;
    for_each(v2.begin(), v2.end(), MyPrint ;//5 6 7 8 9 10 11 12 13 14 30 30 30
    cout << endl;
    vector<int>::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin ;
    for_each(v3.begin(), itEnd, MyPrint ; // 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 30 30 30
    cout << endl;
    cout << *(--itEnd) << endl;
}

int main(){
    test1();
    return 0;
}
```

> 1. 目标容器需要赋予内存空间
> 2. 极端情况，两个容器没有交集，也就是说，目标容器最多需要 `v1.size()+v2.size()` 大小的内存空间

### 7.3  set_difference

将第一个容器中的第二个容器中没有的元素，复制到目标容器中

![image-20231016152523760](../../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231016152523760.png)

```c++
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
using namespace std;

class MyPrint{
    public:
    void operator()(int p){
        cout << p << " ";
    }
};
void test1(){

    // 将大于9 的数都替换成9

    vector<int> v1;
    vector<int> v2;
    vector<int> v3;

    for(int i = 0; i!=10; ++i){
        v1.push_back ;
        v2.push_back(i+5);
    }
    v1.push_back(30);
    v1.push_back(30);
    v1.push_back(30);
    v2.push_back(30);
    v2.push_back(30);
    v3.resize((v1.size()+ v2.size );
    for_each(v1.begin(), v1.end(), MyPrint ;
    cout << endl;
    for_each(v2.begin(), v2.end(), MyPrint ;
    cout << endl;
    vector<int>::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), v3.begin ;
    for_each(v3.begin(), itEnd, MyPrint ; // 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 30 30 30
    cout << endl;
    cout << *(--itEnd) << endl;

    //0 1 2 3 4 5 6 7 8 9 30 30 30 
    //5 6 7 8 9 10 11 12 13 14 30 30
    //0 1 2 3 4 30
    //30
}

int main(){
    test1();
    return 0;
}
```
