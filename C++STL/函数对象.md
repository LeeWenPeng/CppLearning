## 1  STL 函数对象

### 1.1  函数对象

概念：

- 重载**函数调用运算符** `()` 的类
	- 所以其**本质上是一个类**，而非函数
- 因为其使用方式类似于函数，所以也叫**仿函数**

```c++
#include <iostream>
#include <string>

using namespace std;
class MyPrint{
    public:
    MyPrint(){
        m_count = 0;
    }
    void operator() (string s){
        cout << s <<endl;
        m_count++;
    }  
    int m_count; // 类的成员属性作为函数对象的状态
};

void printString(MyPrint &m, const string s){
    m(s);
}

void test1(){
    MyPrint myPrint;

    // 1. 函数对象可以像函数一样调用
    myPrint("hello");
    myPrint("hello");

    // 2. 函数对象可以拥有自己的状态，这个是普通函数所做不到的
    // 通过记录函数调用多少次的参数来演示函数对象的状态
    // 这个所谓的状态，就是一个能记录函数调用相关信息的变量
    // 如果是普通函数想要记录这些信息，比如函数的调用次数等，需要定义一个全局变量来记录
    // 而函数对象可以直接在类的内部定义一个类的成员变量作为类的状态
    cout << myPrint.m_count << endl; // 2

    // 3. 函数对象可以作为参数直接传递
    // 类似于回调函数的概念，但回调函数传递的是函数的指针，而函数对象则是如同普通传参一样，将本身作为参数传递
    printString(myPrint, "hello"); // hello
}   

int main(){
    test1();
    return 0;
}
```

### 1.2  谓词

概念：

- 返回 `bool` 类型的仿函数，称为**谓词**
- 重载函数调用运算符时，函数参数有一个参数的函数对象，称为**一元谓词**
- 重载函数调用运算符时，函数参数有二个参数的函数对象，称为**二元谓词**

> c++ 中 `pred` 一般指代谓词

#### 1.2.1  一元谓词

```c++
#include <algorithm>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class GreaterFive{
    public:
    // 一元谓词
    // 谓词体现在返回值为 bool 类型
    // 一元体现在 只有一个参数
    bool operator() (int val){
        return val > 5;
    }
};

void test1(){
    vector<int> v1;
    for(int i =0; i < 10; ++i){
        v1.push_back(i);
    }
    vector<int>::iterator it = find_if(v1.begin(), v1.end(), GreaterFive());
    if(it == v1.end()){
        cout << "没有找到比五大的数字" << endl;
    }else{
        cout << "找到比五大的数字为：" << *it << endl;
    }
}   

int main(){
    test1();
    return 0;
}
```

> 上述代码中使用了标准算法库中的 `find_if` 函数
>
> 这个函数有三个参数：
>
> ```c++
> find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
> ```
>
> - 第一个是开始迭代器
> - 第二个是结尾迭代器
> - 最后一个就是谓词
>   - 在 C++ 中，pred 一般就指这里需要一个谓词
> 
> 函数源码为：
>
> ```c++
> template<typename _InputIterator, typename _Predicate>
>     inline _InputIterator
>     __find_if(_InputIterator __first, _InputIterator __last,
> 	      _Predicate __pred, input_iterator_tag)
>     {
>       while (__first != __last && !__pred(__first))
> 	++__first;
>       return __first;
>     }
> ```
>
> 最后的返回值是 `__first` 就是经过移动的开始迭代器

#### 1.2.2  二元谓词

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

class People{
public:
    People(int age, string name){
        m_age = age;
        m_name = name;
    }

    int m_age;
    string m_name;
};

// 谓词
// 其中的调用运算符重载函数有两个参数，所以称为二元谓词
class MyCompare{
public:
    bool operator()(int val1, int val2){
        return val1 >= val2;
    }
};
 
void test1(){
    vector<int> v1;
    for (int i = 0; i!=10; ++i) {
        v1.push_back(i);
    }

    for (vector<int>::iterator it = v1.begin(); it!=v1.end(); ++it) {
        cout << *it << endl;
    }
    
    // sort 函数的第三个参数应该是函数
    // 这里传入的是MyCompare类的实例对象
    // sort 函数的第三个参数传递之后的使用是做调用，所以这里必须传递一个对象，这样就可以作为仿函数使用
    sort(v1.begin(), v1.end(), MyCompare());

    for (vector<int>::iterator it = v1.begin(); it!=v1.end(); ++it) {
        cout << *it << endl;
    }
}  

int main(){
    test1();
    return 0;
}
```

### 1.3  内建函数对象

STL 内建了很多仿函数，包括：

- 算术仿函数
- 关系仿函数
- 逻辑仿函数

> 引用这些仿函数需要引用头文件 `#include<functional>`

#### 1.3.1  算术仿函数

功能：实现四则运算

![image-20231011101911450](../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231011101911450.png)

> 其中只有 `negate` 为一元运算，其他的都是二元运算

```c++
#include <iostream>
#include<functional> // STL内建仿函数头文件
using namespace std;

void test1(){

    // 取反仿函数
    negate<int> n;
    // cout << n(50) << endl;

    // 加法仿函数
    plus<int> p;
    cout << p(20,30) <<endl;

}  

int main(){
    test1();
    return 0;
}
```

#### 1.3.2  关系仿函数

![image-20231011102326730](../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231011102326730.png)

```c++
#include <algorithm>
#include <iostream>
#include<functional> // STL内建仿函数头文件
#include <vector>
using namespace std;
class MyCompare{

    public:
    bool operator()(int val1, int val2){
		
        // 大于仿函数
        greater<int> g;
        return g(val1, val2);
    }
};

void test1(){

    vector<int> v1;

    for (int i = 0; i!=10; ++i) {
        v1.push_back(i);
    }

    for(vector<int>::iterator it = v1.begin(); it!=v1.end(); ++it){
        cout << *it << " ";
    }
    cout << endl;

    // sort(v1.begin(), v1.end(), MyCompare());
    // 更方便做法：
    sort(v1.begin(), v1.end(), greater<int>());
    // algorithm 库中的 sort 函数，默认的排序规则是 less<T>

    for(vector<int>::iterator it = v1.begin(); it!=v1.end(); ++it){
        cout << *it << " ";
    }
    cout << endl;
}  

int main(){
    test1();
    return 0;
}
```

algorithm 库中的 sort 函数，默认的排序规则是 `less<T>`

```cpp
struct _Iter_less_iter{
	template<typename _Iterator1, typename _Iterator2>
	_GLIBCXX14_CONSTEXPR
	bool operator()(_Iterator1 __it1, _Iterator2 __it2) const{ 
		return *__it1 < *__it2; 
	}
};
```

> 很容易看出来，这个 less 也是个仿函数

#### 1.3.3  逻辑运算符

![image-20231011103334950](../第一阶段黑马程序员C++课程/lesson06%20-%20c++%20提高编程.assets/image-20231011103334950.png)

> 实际开发中基本用不到

```c++
#include <algorithm>
#include <iostream>
#include<functional> // STL内建仿函数头文件
#include <vector>
using namespace std;
class MyCompare{

    public:
    bool operator()(int val1, int val2){

        greater<int> g;
        return g(val1, val2);
    }
};

void test1(){

    vector<int> v1;

    for (int i = 0; i!=10; ++i) {
        v1.push_back(i);
    }

    vector<int>v2;
    v2.resize(v1.size());

    transform(v1.begin(), v1.end(), v2.begin(), logical_not<int>());

    for (vector<int>::iterator it = v2.begin(); it!= v2.end(); ++it) {
        cout << *it <<endl;
    }
}  

int main(){
    test1();
    return 0;
}
```

transform

```c++
transform(IIter, IIter, OIter, UnaryOperation)
```

 - 第一个参数 `IIter` 迁移起始容器的起始迭代器
 - 第二个参数 `IIter` 迁移起始容器的终止迭代器
 - 第三个参数 `OIter` 迁移目标容器的起始迭代器
 - `UnaryOperation` 迁移规则，这里提供一个函数名或者是仿函数对象
  - 对迁移起始容器中的起始迭代器指向数据做处理

```c++
    transform(_InputIterator __first, _InputIterator __last,
	      _OutputIterator __result, _UnaryOperation __unary_op)
    {
      // concept requirements
     __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
	    // "the type returned by a _UnaryOperation"
	    __typeof__(__unary_op(*__first))>)
      __glibcxx_requires_valid_range(__first, __last);

      for (; __first != __last; ++__first, (void)++__result)
          // 核心代码
	*__result = __unary_op(*__first);
      return __result;
    }
```
