## 匿名管道

创建一个匿名管道，用于父进程与其子进程之间的通信。

```c
 #include <unistd.h>

int pipe(int pipefd[2]);
```

参数

+   数组 `pipefd` 用于返回两个指向管道两端的文件描述符。
    +   `pipefd[0]`表示管道的读取端。
    +   `pipefd[1]`表示管道的写入端。
+   写入管道写入端的数据由内核缓冲，直到从管道读取端读取。
+   返回值
    +   成功：返回0
    +   失败：返回-1，并设置errno

>   [!note] 匿名管道只能在创建它的进程及其子进程中使用。
>
>   它是匿名的，意味着没有名称，只能在创建它的进程及其子进程中使用。

### 管道通信流程

1.   **创建管道**：使用pipe()或mkfifo()创建管道。
2.   **关闭不需要的端**：在父进程和子进程中，关闭不需要使用的文件描述符，以避免数据无法正确传输。
3.   **数据传输**：通过write()系统调用向管道写入数据，通过read()系统调用从管道读取数据。
4.   **关闭管道**：在数据传输完成后，关闭管道文件描述符，释放资源。



### 设置管道非堵塞 - fcntl

通过 fcntl 对管道的文件描述符进行设置

1.   获取文件描述符原有的flags
2.   更新 flags：`O_NONBLOCK`非阻塞模式
3.   设置文件描述符

```c
int flags = fcntl(fd[0], F_GETFL); 
flags != O_NONBLOCK;
fcntl(fd[0], F_SETFL, flags)
```



### 匿名管道特点

#### 单向通信

+   普通管道是半双工的，数据只能在一个方向流动。
+   使用管道的进程，需要关闭不需要的端。
+   如果需要双向通信，通常需要创建两个管道。

#### 默认阻塞

**默认情况下，管道是阻塞的**。因此，在使用管道时，有几种特殊的情况：

1.   管道写端引用次数为0：如果所有指向管道写端的文件描述符都关闭，有进程从管道读端读取数据。那么，管道剩余数据首先会被读取。之后，read 会返回0（管道已空）。
2.   管道写端引用次数大于0：如果有指向管道写端的文件描述符没有关闭，而持有管道写端的进程没有往管道中写数据 ，这时候有进程从管道中读取数据。那么，管道剩余数据首先会被读取。之后，read 会暂时被阻塞，直到管道中有数据可以读取后，才读取数据并返回。
3.   管道读端引用次数为0：如果所有指向管道读端的文件描述符都关闭了，这时有进程向管道写入数据。那么，该进程会收到一个信号 `SIGPIPE`。该信号通常会导致进程异常终止。
4.   管道读端引用次数大于0：如果有指向管道读端的文件描述符没有关闭，而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据。那么，管道将会成功写入数据，直到被写满为止。之后，write 会暂时被阻塞，直到管道中有空余位置时，才能再次写入数据并返回。

总结：

+   读数据
    +   管道中有数据，read返回实际读到的字节数
    +   管道中无数据
        +   写端被全部关闭，read 返回0，相当于读到文件末尾
        +   写段没有完全关闭，read会阻塞等待
+   写管道
    +   管道读端全部被关闭，进程异常终止
    +   管道读端没有全部关闭
        +   管道已满，write 阻塞
        +   管道未满，write 将数据写入，并返回实际写入的字节数

## 有名管道 FIFO

FIFO（先进先出），在文件系统中创建一个名称，以便不相关的进程之间也能进行通信。

### 语法

bash 命令

```bash
mkfifo name
```

系统调用语法

```c
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode); 
```

+   参数
    +   `pathname`：管道名称
    +   `mode`：权限
        +   `mode & ~umask`
        +   和`open()`函数的参数`mode`是一样的
+   返回值
    +   成功，返回0
    +   失败，返回 -1，并设置 errno

### FIFO文件和普通文件

+   支持常见的I/O函数，如`close()`、`read()`、`write()`、`ulink()`等

+   不支持文件定位操作，例如`lseek()`

### FIFO 与管道

| 特性         | 匿名管道(pipe)                             | 命名管道(FIFO)                                           |
| :----------- | :----------------------------------------- | :------------------------------------------------------- |
| 命名         | 没有名称，匿名创建                         | 有名称，存在于文件系统                                   |
| 创建方式     | `pipe()`                                   | `mkfifo()`                                               |
| 访问范围     | 创建它的进程及其子进程之间                 | 在文件系统中通过名称被任何有权限的进程访问               |
| 生命周期     | 随创建进程结束自动释放                     | 需要显式删除文件节点                                     |
| 打开方式     | 通过`pipe()`返回的文件描述符进行读写操作   | 通过`open()`系统调用打开FIFO文件进行读写操作             |
| 数据传输方向 | 默认单向，需要通过两个管道实现双向         | 默认单向，需要通过FIFO文件实现双向                       |
| 同步与异步   | 支持阻塞和非阻塞模式                       | 支持阻塞和非阻塞模式                                     |
| 用途         | 适用于父子进程之间的简单通信               | 适用于不同进程之间的通信，特别是需要持久化通信通道的场景 |
| 权限管理     | 不涉及系统权限                             | 需要设置合适的文件权限，以控制进程的访问                 |
| 系统资源     | 不占用文件系统的节点                       | 占用文件系统的一个节点，需要管理和清理                   |
| 先进先出原则 | 严格遵守，在开始处返回数据，在末尾添加数据 | 严格遵守，在开始处返回数据，在末尾添加数据               |

