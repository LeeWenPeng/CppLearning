## 1  定义

静态多态（Static Polymorphism），也称为编译时多态（Compile-time Polymorphism），是指在**编译期间**确定具体调用哪个函数或操作的多态形式。编译器在编译阶段根据上下文信息（如类型信息、参数类型等）决定具体调用的实现，而非在运行时动态决定。

## 2  ## 3 与动态多态的区别

- 绑定时机：
	- 静态多态在编译期进行绑定
	- 动态多态在运行时进行绑定
- 实现机制：
	- 静态多态通过模板、重载等机制
	- 动态多态通过虚函数
- 特点
	- 静态多态性能更好，因为无运行时查找开销
	- 动态多态更灵活，在运行时可以改变行为

2 主要实现方式

1. 函数重载
2. 运算符重载
3. 模板

## 3  函数重载

- 允许在同一个作用域内声明多个同名函数，但这些函数的参数列表必须不同（参数类型、参数个数、参数顺序）必须不同。仅返回值类型不同不能构成重载
- 编译器根据调用时提供的实参类型和数量，在编译时选择最匹配的函数版本。

## 4  运算符重载

- 运算符重载允许为自定义类型定义运算符的行为，本质上是一种特殊的函数重载，函数名由 `operator` 关键字后接运算符符号组成。

### 4.1  特殊运算符重载

```cpp
class Array {
    int* data;
    size_t size;
public:
    // 下标运算符 []
    int& operator[](size_t index) {
        if (index >= size) throw out_of_range("Index out of bounds");
        return data[index];
    }
    
    const int& operator[](size_t index) const {
        return const_cast<Array*>(this)->operator[](index);
    }
    
    // 函数调用运算符 ()
    int operator()(int x, int y) const {
        return data[x] + data[y];
    }
    
    // 类型转换运算符
    explicit operator bool() const {
        return size > 0 && data != nullptr;
    }
    
    // 成员访问运算符 ->
    Array* operator->() {
        return this;
    }
    
    // 解引用运算符 *
    int& operator*() {
        return data[0];
    }
};
```

### 4.2  运算符重载的限制与规则

1. 不能重载的运算符
	1. `::`：作用域解析
	2. `.`：成员访问
	3. `.*`：成员指针访问
	4. `?:`：三元条件运算符
	5. `sizeof`
	6. `typeid`
2. 不能改变运算符的优先级和结合性
3. 不能创建新的运算符
4. 重载运算符至少一个操作符是类类型或枚举类型

## 5  模板

模板是 C++ 实现泛型编程的基础，包括函数模板和类模板。模板允许我们编写与类无关的代码。

### 5.1  模板元编程

模板元编程是利用模板在编译期进行计算和类型推导的技术。

#### 5.1.1  例子：编译期计算阶乘

```cpp
template<int N>
struct Factorial {
    static const int value = N * Factorial<N-1>::value;
};

template<>
struct Factorial<0> {
    static const int value = 1;
};

int main() {
    cout << Factorial<5>::value << endl;  // 输出120，在编译时计算
    return 0;
}
```

### 5.2  CRTP

CRTP 是一种使用模板实现静态多态的技术。

它通过将**派生类**作为模板参数传递给基类，使得基类可以调用派生类的方法

```cpp
// CRTP基类模板
template<typename Derived>
class Base {
public:
    void interface() {
        // 编译时转换为派生类类型
        static_cast<Derived*>(this)->implementation();
    }
    
    // 可以调用派生类的静态方法
    static void staticInterface() {
        Derived::staticImplementation();
    }
    
    // 访问派生类成员
    Derived& derived() { 
	    return *static_cast<Derived*>(this); 
	}
    
    const Derived& derived() const { 
	    return *static_cast<const Derived*>(this); 
	}
};

// 派生类
class Concrete : public Base<Concrete> {
public:
    void implementation() {
        cout << "Concrete implementation" << endl;
    }
    
    static void staticImplementation() {
        cout << "Concrete static implementation" << endl;
    }
    
    // 派生类特有方法
    void extraFunction() { cout << "Extra function" << endl; }
};

// 使用
void useCRTP() {
    Concrete obj;
    obj.interface();  // 调用Concrete::implementation()
    obj.derived().extraFunction();  // 访问派生类特有方法
    Concrete::staticInterface();  // 调用静态多态
}
```

### 5.3  可变参数模板

允许模板接受任意数量和类型的参数

```cpp
#include <iostream>
using namespace std;

// 递归终止函数
void print() {
    cout << endl;
}

// 可变参数模板
template <typename T, typename… Args>
void print(T first, Args… args) {
    cout << first << " ";
    print(args…);
}

int main() {
    print(1, 2.5, "hello", 'a');   // 输出: 1 2.5 hello a 
    return 0;
}
```

### 5.4  模板特化

可以为特定的类型提供模板的特殊版本

```cpp
#include <iostream>
using namespace std;

// 通用模板
template <typename T>
class Printer {
public:
    void print(T value) {
        cout << "通用打印: " << value << endl;
    }
};

// 特化版本，针对int类型
template <>
class Printer<int> {
public:
    void print(int value) {
        cout << "整数打印: " << value << endl;
    }
};

int main() {
    Printer<string> p1;
    p1.print("Hello");   // 使用通用模板
    
    Printer<int> p2;
    p2.print(42);        // 使用特化版本
    
    return 0;
}
```

## 6  优化

### 6.1  constexpr 函数

constexpr 函数在编译时求值，是静态多态的重要补充。

```cpp
// C++11: 简单的constexpr函数
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

// C++14: 更强大的constexpr
constexpr auto compute() {
    std::array<int, 10> arr{};
    for (size_t i = 0; i < arr.size(); ++i) {
        arr[i] = i * i;
    }
    return arr;  // 编译时计算数组
}

// C++20: constexpr虚函数（有限支持）
struct Base {
    virtual constexpr int value() const = 0;
};

struct Derived : Base {
    constexpr int value() const override { return 42; }
};
```

### 6.2  if constexpr

编译时条件判断，允许基于模板参数选择不同代码路径。

```cpp
template<typename T>
auto process(T value) {
    if constexpr (std::is_pointer_v<T>) {
        // 仅当T是指针类型时编译此分支
        return *value;
    } else if constexpr (std::is_integral_v<T>) {
        // 仅当T是整数类型时编译此分支
        return value * 2;
    } else {
        // 其他情况
        return value;
    }
}

// 传统方式需要多个重载或特化
// if constexpr更简洁
```
