## 1  单例模式在跨 ELF 模块环境下的多实例问题分析

### 1.1  问题概述

#### 1.1.1  核心问题

在跨 ELF 模块（动态库）环境中，即使采用了单例设计模式，仍然可能出现多个单例对象的情况，这与符号解析、链接器行为和模块边界密切相关。

#### 1.1.2  根本原因

同名单例模式在多个 ELF 模块中存在，当采用运行时动态链接时，在某些情况下动态链接器无法将这些单例模式解析到同一份定义，导致多实例产生。

### 1.2  技术背景知识

#### 1.2.1  符号属性与可见性

##### 2.1.1 GCC 符号可见性

- **默认可见性（default）**：符号全局可见，可被其他模块引用
- **隐藏可见性（hidden）**：符号仅在当前模块内可见
- **受保护可见性（protected）**：符号全局可见但不可被覆盖
- **内部可见性（internal）**：类似 hidden，但有额外的语义限制

##### 2.1.2 符号定义强度

```cpp
// 强符号定义
int global_var = 1;           // 强定义
void strong_function() {}     // 强定义

// 弱符号定义  
__attribute__((weak)) int weak_var = 1;           // 弱定义
__attribute__((weak)) void weak_function() {}     // 弱定义
```

#### 1.2.2  链接器符号处理规则

##### 2.2.1 符号解析优先级

1. **强符号优先**：强符号覆盖弱符号
2. **多重强符号冲突**：链接错误
3. **多重弱符号**：链接器任选其一

##### 2.2.2 跨模块符号合并

- 对于可导出的弱定义符号，链接器会进行合并
- 隐藏可见性的符号不参与跨模块合并
- 动态链接与静态链接的符号处理策略不同

### 1.3  多实例场景详细分析

#### 1.3.1  情况一：Hidden Visibility 导致的模块隔离

##### 3.1.1 问题机制

```cpp
// 在动态库中定义hidden可见性的单例
class __attribute__((visibility("hidden"))) Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;  // 每个模块独立实例
        return instance;
    }
private:
    Singleton() = default;
};
```

**问题分析：**
1. `hidden` 属性阻止符号导出到动态符号表
2. 链接器无法进行跨模块符号解析和合并
3. 每个包含该定义的 ELF 模块都会创建独立的单例实例

##### 3.1.2 实际场景示例

```bash
# 编译包含hidden单例的动态库
g++ -shared -fPIC -fvisibility=hidden -o libmodule1.so module1.cpp
g++ -shared -fPIC -fvisibility=hidden -o libmodule2.so module2.cpp

# 主程序也包含相同单例定义
g++ main.cpp -L. -lmodule1 -lmodule2 -o main
```

**结果**：三个模块各自拥有独立的单例实例。

##### 3.1.3 验证方法

```bash
# 检查符号可见性
nm -D libmodule1.so | grep Singleton
readelf -s libmodule1.so | grep Singleton

# 检查实际实例地址（在代码中添加）
printf("Singleton address: %p\n", &Singleton::getInstance());
```

#### 1.3.2  情况二：动态加载与弱符号冲突

##### 3.2.1 问题机制

```cpp
// 主程序中的单例（强符号）
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;  // 主程序实例
        return instance;
    }
};

// 动态库中的单例（弱符号）  
class __attribute__((weak)) Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;  // 动态库实例
        return instance;
    }
};
```

**问题分析：**
1. 主程序包含强符号定义
2. 动态库通过 `dlopen` 运行时加载，包含弱符号定义
3. 链接器不会用弱符号覆盖已存在的强符号
4. 主程序与动态库使用不同的单例实例

##### 3.2.2 动态加载场景

```cpp
// 主程序
int main() {
    auto& main_instance = Singleton::getInstance();
    printf("Main instance: %p\n", &main_instance);
    
    // 运行时加载动态库
    void* handle = dlopen("./libplugin.so", RTLD_LAZY);
    if (handle) {
        void (*plugin_func)() = (void(*)())dlsym(handle, "plugin_function");
        if (plugin_func) plugin_func();
        dlclose(handle);
    }
    
    return 0;
}

// 动态库插件
extern "C" void plugin_function() {
    auto& plugin_instance = Singleton::getInstance();
    printf("Plugin instance: %p\n", &plugin_instance);  // 地址不同！
}
```

##### 3.2.3 符号表分析

```bash
# 查看主程序符号
nm main | grep Singleton
# 输出: 0000000000401234 W Singleton::getInstance()  # 强符号

# 查看动态库符号  
nm -D libplugin.so | grep Singleton
# 输出: 0000000000000abc W Singleton::getInstance()  # 弱符号
```

### 1.4  解决方案与最佳实践

#### 1.4.1  方案一：统一符号导出

##### 4.1.1 确保默认可见性

```cpp
// 显式指定default visibility
class __attribute__((visibility("default"))) Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
private:
    Singleton() = default;
};
```

##### 4.1.2 集中式单例库

```cmake
# CMakeLists.txt - 创建统一的单例共享库
add_library(singleton_lib SHARED singleton.cpp)
target_compile_options(singleton_lib PRIVATE -fvisibility=default)

# 其他模块链接该库
target_link_libraries(main_app singleton_lib)
target_link_libraries(plugin_module singleton_lib)
```

#### 1.4.2  方案二：显式单例管理

##### 4.2.1 单例注册表模式

```cpp
class SingletonRegistry {
public:
    template<typename T>
    static T& getSingleton(const std::string& name) {
        std::lock_guard<std::mutex> lock(mutex_);
        auto it = instances_.find(name);
        if (it == instances_.end()) {
            it = instances_.emplace(name, std::make_unique<T>()).first;
        }
        return *static_cast<T*>(it->second.get());
    }
    
    template<typename T>
    static void registerSingleton(const std::string& name, T* instance) {
        std::lock_guard<std::mutex> lock(mutex_);
        instances_[name] = std::unique_ptr<void>(instance);
    }

private:
    static std::unordered_map<std::string, std::unique_ptr<void>> instances_;
    static std::mutex mutex_;
};
```

##### 4.2.2 接口抽象与依赖注入

```cpp
// 单例接口
class ISingleton {
public:
    virtual ~ISingleton() = default;
    virtual void operation() = 0;
};

// 具体实现
class ConcreteSingleton : public ISingleton {
public:
    static std::shared_ptr<ISingleton> getInstance() {
        static std::shared_ptr<ConcreteSingleton> instance = 
            std::make_shared<ConcreteSingleton>();
        return instance;
    }
    
    void operation() override { /* 实现 */ }
};

// 通过接口访问，避免直接依赖具体类
```

#### 1.4.3  方案三：编译期控制

##### 4.3.1 可见性统一控制

```cpp
// visibility_control.h
#pragma once

#if defined(SINGLETON_EXPORT)
    #define SINGLETON_API __attribute__((visibility("default")))
#else
    #define SINGLETON_API __attribute__((visibility("hidden")))
#endif

// singleton.h
class SINGLETON_API Singleton {
    // 单例实现
};
```

##### 4.3.2 构建系统配置

```cmake
# 单例库编译时导出符号
add_library(singleton SHARED singleton.cpp)
target_compile_definitions(singleton PRIVATE SINGLETON_EXPORT)

# 使用者编译时隐藏符号
add_library(user_module SHARED user_code.cpp)
target_compile_definitions(user_module PRIVATE SINGLETON_IMPORT)
```

#### 1.4.4  方案四：运行时单例协调

##### 4.4.1 显式实例传递

```cpp
// 主程序初始化单例并传递给插件
void initialize_plugins() {
    auto& singleton = Singleton::getInstance();
    
    void* handle = dlopen("./libplugin.so", RTLD_LAZY);
    if (handle) {
        using InitFunc = void(*)(Singleton*);
        InitFunc init_plugin = (InitFunc)dlsym(handle, "initialize_plugin");
        if (init_plugin) {
            init_plugin(&singleton);  // 传递单例实例
        }
    }
}
```

##### 4.4.2 环境变量通信

```cpp
// 通过环境变量传递单例信息（适用于简单场景）
class DistributedSingleton {
public:
    static Singleton& getInstance() {
        static Singleton* instance = nullptr;
        if (!instance) {
            // 尝试从环境变量获取已有实例信息
            const char* existing = std::getenv("SINGLETON_INSTANCE");
            if (existing) {
                // 使用现有实例逻辑
            } else {
                instance = new Singleton();
                // 设置环境变量标识
                setenv("SINGLETON_INSTANCE", "created", 1);
            }
        }
        return *instance;
    }
};
```

### 1.5  检测与调试技术

#### 1.5.1  编译期检测

##### 5.1.1 静态断言检查

```cpp
class Singleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        
        // 编译期检查确保正确链接
        static_assert(!std::is_same<decltype(instance), 
                      typename std::remove_reference<decltype(instance)>::type>::value,
                      "Singleton visibility issue detected");
        return instance;
    }
};
```

##### 5.1.2 符号可见性验证脚本

```bash
#!/bin/bash
# check_singleton_visibility.sh

check_module() {
    local module=$1
    echo "Checking $module:"
    
    # 检查Singleton符号
    nm -C -D "$module" | grep -i singleton | while read line; do
        if echo "$line" | grep -q " [Ww] "; then
            echo "  WARNING: Weak symbol found"
        elif echo "$line" | grep -q " [Tt] "; then
            echo "  OK: Strong symbol"
        else
            echo "  UNKNOWN: Other symbol type"
        fi
    done
}
```

#### 1.5.2  运行时检测

##### 5.2.1 实例一致性检查

```cpp
class Singleton {
private:
    static std::atomic<Singleton*> global_instance{nullptr};
    
public:
    static Singleton& getInstance() {
        static Singleton instance;
        
        // 检测多实例
        Singleton* expected = nullptr;
        if (!global_instance.compare_exchange_strong(expected, &instance)) {
            if (expected != &instance) {
                std::cerr << "SINGLETON VIOLATION: Multiple instances detected!" << std::endl;
                std::cerr << "Existing: " << expected << ", New: " << &instance << std::endl;
                // 处理策略：终止程序或使用现有实例
                std::terminate();
            }
        }
        return instance;
    }
};
```

##### 5.2.2 调试信息收集

```cpp
class DebuggableSingleton {
public:
    static Singleton& getInstance() {
        static Singleton instance;
        
        // 记录实例创建信息
        static bool first_creation = true;
        if (first_creation) {
            first_creation = false;
            std::cout << "Singleton created at: " << &instance 
                      << " in module: " << get_module_name() 
                      << " at: " << __FILE__ << ":" << __LINE__ << std::endl;
        }
        return instance;
    }
    
private:
    static const char* get_module_name() {
        Dl_info info;
        if (dladdr((void*)get_module_name, &info)) {
            return info.dli_fname;
        }
        return "unknown";
    }
};
```

### 1.6  总结与建议

#### 1.6.1  根本原因总结

1. **符号可见性隔离**：`hidden` visibility 阻止跨模块符号解析
2. **链接器行为限制**：弱符号不能覆盖强符号，不同模块间符号合并受限
3. **ELF 模块边界**：每个模块拥有独立的静态存储期对象

#### 1.6.2  最佳实践建议

##### 设计阶段

- **明确单例范围**：确定单例应该是进程全局还是模块局部
- **接口抽象**：通过抽象接口减少对具体单例类的直接依赖
- **依赖注入**：考虑使用依赖注入框架管理单例生命周期

##### 实现阶段  

- **统一可见性**：确保跨模块单例使用 `default` visibility
- **集中管理**：将全局单例放在独立的共享库中
- **编译控制**：使用构建系统严格控制符号导出

##### 验证阶段

- **多环境测试**：在静态链接和动态链接环境下分别测试
- **符号审计**：定期检查生成二进制文件的符号表
- **运行时监控**：在生产环境中加入实例一致性检查

通过理解 ELF 模块机制和链接器行为，并采用适当的设计模式和工程实践，可以有效避免单例模式在复杂模块化环境中的多实例问题。
