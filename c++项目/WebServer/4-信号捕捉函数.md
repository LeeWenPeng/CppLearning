## 信号处理的流程

在Linux系统中，信号处理的流程可以概括为以下步骤，结合了内核与用户态的协作：

1. **触发内核入口**  
   当进程执行时，因中断、异常或系统调用进入内核态。例如，硬件中断触发上下文切换，或进程主动调用系统调用（如`read`），或发生异常（如缺页错误）。

2. **内核处理与信号检查**  
   内核完成中断/异常/系统调用的处理后，在返回用户态**前**，检查当前进程是否有**待处理且未被阻塞的信号**。若有，则进入信号递送流程。

3. **用户态信号处理函数执行**  
   - 若信号的处置是**默认动作**（如终止进程）或**忽略**，内核直接处理（如终止进程）。  
   - 若信号的处理是**用户自定义函数**（通过`signal()`或`sigaction()`注册），内核会：  
     a. **保存原始上下文**：将当前寄存器状态（如`eip/rip`、`esp/rsp`等）保存到用户栈或内核栈。  
     b. **修改返回上下文**：将用户态的返回地址设置为信号处理函数的入口，并可能设置备用栈（若使用`sigaltstack`）。  
     c. **调整信号屏蔽字**：通常阻塞当前信号，防止递归触发。

4. **信号处理完成与`sigreturn`系统调用**  
   - 信号处理函数执行完毕后，**不会直接返回到主流程**，而是通过预置的代码调用`sigreturn`（或`rt_sigreturn`）再次进入内核。  
   - 此步骤通常由C库自动处理。例如，内核在设置信号处理函数时，会将返回地址指向一段调用`sigreturn`的代码，确保函数返回后触发该系统调用。

5. **恢复上下文并继续执行**  
   - 内核通过`sigreturn`恢复之前保存的原始上下文（包括寄存器、栈指针、程序计数器等）。  
   - 最终返回到用户态，继续执行主流程中被中断的指令。

**关键机制与细节**  
- **信号队列与优先级**：实时信号（如`SIGRTMIN`+n）支持排队，而标准信号（如`SIGINT`）同一时刻仅记录一次。内核按信号编号顺序递送。  
- **栈帧管理**：内核可能向用户栈插入`ucontext`结构，保存原始状态。信号处理函数的栈可以是独立备用栈，避免栈溢出。  
- **信号屏蔽**：执行处理函数时，该信号通常被自动阻塞（通过`sigaction`的`sa_mask`可扩展阻塞信号集）。  
- **嵌套信号处理**：若在处理函数中收到其他信号，内核会根据当前屏蔽字决定是否递送，可能导致嵌套处理。

## 信号捕捉的特性

+   被阻塞的信号，将不会参与派对
    +   

## signal

功能

+   设置某个信号的捕捉行为

语法

```C
#include <signal.h>

typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);

```

+   参数
    +   signum：要捕捉的信号
    +   handler：是一个函数指针，捕捉到信号后，要如何处理
        +   `SIG_IGN`：忽略信号
        +   `SIG_DEL`：使用信号默认行为
        +   回调函数指针：设置对信号的处理行为
+   返回值
    +   成功：返回上一次注册的信号的处理函数地址。
        +   第一次调用返回 NULL
    +   失败：返回SIG_ERR，并且设置 errno。

>   [!note] 注意！
>
>   `SIGKILL `、`SIGSTOP`不能被捕捉，也不能被忽略

>   [!warning] 尽量使用 sigaction，而非signal。

## sigaction

功能

用于修改进程在接收到特定信号时采取的动作。

语法

```c
#include <signal.h>
int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);
```

+   参数
    +   signum：需要捕捉的信号编号或宏
        +   除了`SIGKILL` 和 `SIGSTOP`
    +   act：如果非空，则将指定捕捉信号后相应的处理动作。
    +   oldact：如果非空，则将信号之前的处理动作保存在 oldact 中。
        +   一般不使用，指定 `NULL`。
+   返回值
    +   成功：0
    +   失败：-1，并设置 errno

### sigaction 结构体

```C
struct sigaction {
	void     (*sa_handler)(int);
    void     (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t   sa_mask;
    int        sa_flags;
    void     (*sa_restorer)(void);
};
```

+   结构体成员
    +   sa_handler：函数指针，指向的函数为信号处理函数。
    +   sa_sigaction：函数指针，不常用。
    +   sa_mask：**临时阻塞信号集**
        +   在 `sigaction()` 函数执行时，使用的阻塞信号集为 `sa_mask`
        +   在`sigaction()` 函数执行后，使用的阻塞信号集切换为 
    +   sa_flags： 用于指定一组标志位，通过按位或（`|`）组合以下零个或多个选项，以修改信号的行为特性：
        +   `0`：指定处理函数为 sa_handler
        +   `SA_SIGINFO`：指定处理函数为 sa_sigaction
        +   ...
    +   sa_restorer：被弃用

## 信号捕捉函数的特性

### **1. `sigaction()` 的阻塞信号集 `sa_mask`**
- **作用时机**：`sa_mask` 指定的信号集会在**信号处理函数执行期间**被阻塞，而非在 `sigaction()` 函数调用时立即生效。
- **自动阻塞当前信号**：默认情况下，内核会在执行信号处理函数时自动将**当前信号**（正在处理的信号）添加到阻塞集中（除非使用 `SA_NODEFER` 标志）。这是为了防止同一信号的递归触发。
- **恢复机制**：当信号处理函数执行完毕（通过 `sigreturn` 系统调用返回内核），内核会恢复进程**原有的阻塞信号集**。例如：
  
  ```c
  struct sigaction sa;
  sigemptyset(&sa.sa_mask);
  sigaddset(&sa.sa_mask, SIGUSR1); // 处理 SIGINT 时阻塞 SIGUSR1
  sa.sa_flags = 0;
  sa.sa_handler = handler;
  sigaction(SIGINT, &sa, NULL);
  ```
  - 当 `SIGINT` 处理函数 `handler` 执行时，`SIGINT`（自动）和 `SIGUSR1`（手动添加）均被阻塞。
  - `handler` 执行结束后，阻塞集会恢复为调用 `handler` 之前的状态。

---

### **2. 执行信号处理函数期间默认屏蔽该信号**
- **默认行为**：若未设置 `SA_NODEFER` 标志，执行信号处理函数时，内核会自动将当前信号（如 `SIGINT`）添加到阻塞信号集中。这避免了信号处理函数未完成时，同一信号再次触发导致的**重入问题**。
- **手动控制**：若需允许嵌套处理同一信号，可通过 `sa_flags` 设置 `SA_NODEFER`：
  ```c
  sa.sa_flags |= SA_NODEFER; // 允许 SIGINT 处理函数执行期间接收新的 SIGINT
  ```

---

### **3. 阻塞的常规信号不支持排队**
- **常规信号（1~31）**：
  - **未决信号集**：每个信号对应一个二进制标志位（非计数器）。若信号被阻塞（处于阻塞状态），后续发送的同一信号仅标记为未决一次。例如：
    - 进程阻塞 `SIGINT`（Ctrl+C）时，连续发送3次 `SIGINT`，未决信号集中 `SIGINT` 位保持为1。
    - 当解除阻塞后，进程仅处理一次 `SIGINT`。
  - **丢失信号**：若信号在处理期间再次到达，可能被丢弃（取决于内核实现和信号类型）。
- **实时信号（`SIGRTMIN`~`SIGRTMAX`）**：
  - **支持排队**：同一实时信号多次发送会被记录为多个未决实例（按到达顺序处理）。
  - **优先级**：实时信号编号越小优先级越高（如 `SIGRTMIN+1` 优先于 `SIGRTMIN+2`）
