## 1  变量基础

### 1.1  变量命名规则

- **区分大小写**：`VAR` 和 `var` 是两个不同的变量
- **不能包含特殊字符**：`:`、`#`、`=` 不能出现在变量名中
- **建议使用大写字母**：约定俗成的做法，便于与命令区分

### 1.2  变量定义与引用

```makefile
# 定义变量
CC = gcc
CFLAGS = -Wall -O2

# 引用变量（两种方式等价）
$(CC)
${CC}

# 示例：使用变量
app: main.c
    $(CC) $(CFLAGS) -o app main.c
```

### 1.3  打印 `$` 字符

```makefile
# 使用 $$ 转义 $
dollar_sign := $$
show_dollar:
    echo "Dollar sign: $(dollar_sign)"
```

### 1.4  环境变量

```makefile
# 可以直接引用系统中的环境变量
show_home:
    echo "Home directory: $(HOME)"
    echo "Path: $(PATH)"
```

## 2  变量赋值方式

### 2.1  简单赋值（立即展开）

```makefile
# 使用 := 或 ::=
VAR1 := $(shell date)  # 立即执行date命令并赋值
VAR2 ::= immediate value

# 示例：立即展开的特点
BEFORE := later
AFTER := $(BEFORE)  # 此时BEFORE的值为"later"
BEFORE = now

test_immediate:
    echo "AFTER = $(AFTER)"  # 输出: later
```

### 2.2  递归展开赋值（延迟展开）

```makefile
# 使用 =
VAR1 = $(shell date)  # 每次引用时执行date命令
VAR2 = deferred value

# 示例：延迟展开的特点
BEFORE = later
AFTER = $(BEFORE)  # 只是记录引用关系
BEFORE = now

test_deferred:
    echo "AFTER = $(AFTER)"  # 输出: now
```

### 2.3  条件赋值

```makefile
# 使用 ?=
# 只有当变量未定义时才赋值
VAR ?= default_value

# 示例
VAR1 = original
VAR1 ?= new_value
VAR2 ?= new_value

show_values:
    echo "VAR1 = $(VAR1)"  # 输出: original
    echo "VAR2 = $(VAR2)"  # 输出: new_value
```

### 2.4  追加赋值

```makefile
# 使用 +=
CFLAGS = -Wall
CFLAGS += -O2  # CFLAGS现在为"-Wall -O2"

# 示例
SOURCES = main.c
SOURCES += utils.c  # SOURCES现在为"main.c utils.c"
```

### 2.5  Shell 命令赋值

```makefile
# 使用 !=
FILES != ls *.c  # 执行shell命令并将结果赋给FILES
TIMESTAMP != date +%s

# 示例
show_files:
    echo "Files: $(FILES)"
```

## 3  变量展开时机

### 3.1  立即展开 vs 延迟展开

```makefile
# 立即展开示例
IMMEDIATE := $(shell echo "立即执行")
# 在解析阶段执行: echo "立即执行"
# 结果: IMMEDIATE = "立即执行"

# 延迟展开示例
DEFERRED = $(shell echo "延迟执行")
# 在引用阶段执行

test_expansion:
    echo "立即: $(IMMEDIATE)"
    echo "延迟: $(DEFERRED)"
```

### 3.2  复杂示例

```makefile
# 直接展开的情况
file1 := $(objs)
# 此时file1为空，因为objs还未定义

# 延迟展开的情况
file2 = $(objs)
# file2记录了对objs的引用

objs = block.o command.o i18n.o

test:
    echo "file1 = $(file1)"  # 输出: (空)
    echo "file2 = $(file2)"  # 输出: block.o command.o i18n.o
```

### 3.3  二次展开

```makefile
# 通过 .SECONDEXPANSION 关键字将变量设置为延迟展开
.SECONDEXPANSION:

# 使用 $$ 进行二次展开
VAR = final_value
TARGET: prereq $$(VAR)

# 相当于：
# TARGET: prereq $(VAR)
# 但在执行时才会展开VAR

# 示例
DEP = dependency
target: $$(DEP)
    @echo "Building $@ with $<"

dependency:
    @touch dependency
```

## 4  多行变量

```makefile
# 使用define定义多行变量
define HELP_MESSAGE
Usage: make [target]
Available targets:
    all     - Build everything
    clean   - Remove build artifacts
    test    - Run tests
endef

# 使用
help:
    @echo "$(HELP_MESSAGE)"

# 也可以用于定义复杂的命令序列
define COMPILE_COMMAND
$(CC) $(CFLAGS) -c $< -o $@
@echo "Compiled $< to $@"
endef

%.o: %.c
    $(COMPILE_COMMAND)
```

## 5  变量操作

### 5.1  取消变量定义

```makefile
VAR = some_value
undefine VAR
# 现在VAR未定义
```

### 5.2  变量覆盖

```makefile
# Makefile内部定义
CC = gcc

# 命令行覆盖
# make CC=clang

# 使用override防止覆盖
override CFLAGS = -Wall -O2
# 即使 make CFLAGS="-g" 也不会覆盖
```

### 5.3  变量替换

```makefile
# 基本语法: $(var:pattern=replacement)
SOURCES = main.c utils.c helper.c
OBJECTS = $(SOURCES:.c=.o)  # 结果: main.o utils.o helper.o

# 复杂示例
FILES = main.cpp utils.cpp helper.cpp
OBJS = $(FILES:%.cpp=build/%.o)  # 结果: build/main.o build/utils.o build/helper.o

# 通配符替换
SRC_DIR = src
SRCS = $(wildcard $(SRC_DIR)/*.c)
OBJS = $(SRCS:$(SRC_DIR)/%.c=build/%.o)
```

## 6  特殊变量

### 6.1  自动变量

在 Makefile 中，**自动变量**是在规则执行时由 `make` 自动填充的特殊变量，它们代表与当前规则相关的特定目标或依赖项。

| 自动变量                      | 含义                   | 典型场景示例                                |
| :------------------------ | :------------------- | :------------------------------------ |
| **`$@`**                  | **当前规则的目标文件名**       | 指定输出文件名：`g++ -o $@ $^`                |
| **`$<`**                  | **第一个依赖项的文件名**       | 编译单个源文件：`g++ -c $< -o $@`             |
| **`$^`**                  | **所有不重复的依赖项列表**      | 链接所有目标文件：`g++ $^ -o $@`               |
| **`$?`**                  | **所有比目标更新的依赖项列表**    | 仅重新编译有变化的文件（不常用）                      |
| **`$*`**                  | **与模式规则匹配的词干 (stem)** | 用于从 `.cpp` 生成 `.o`：`$*.cpp` -> `$*.o` |
| **`$(@D)`**               | **目标文件的目录部分**        | 确保输出目录存在：`mkdir -p $(@D)`             |
| **`$(@F)`**               | **目标文件的文件名部分**       | （较少直接使用）                              |
| **`$(<D)`** / **`$(<F)`** | **第一个依赖项的目录/文件名部分**  | 处理依赖项的路径                              |

> [!note] **`$^` 与 `$+` 的区别**
> -   `$^`：移除所有重复的依赖项。
> -   `$+`：保留所有依赖项的顺序和重复。当库的链接顺序很重要时（例如 `-lpthread` 需要放在特定位置），可能需要使用 `$+`。

```makefile
app: main.o utils.o
    # $@ = app (目标名)
    # $^ = main.o utils.o (所有依赖)
    $(CC) $^ -o $@

%.o: %.c
    # $< = 第一个依赖文件
    # $* = 文件名主干（不含扩展名）
    $(CC) -c $< -o $@

# 自动变量完整示例
target: dep1 dep2 dep3 | order_only
    @echo "Target: $@"
    @echo "First prerequisite: $<"
    @echo "All newer prerequisites: $?"
    @echo "All prerequisites: $^"
    @echo "All prerequisites (with duplicates): $+"
    @echo "Order-only prerequisites: $|"
```

### 6.2  预定义变量

```makefile
# 常用的预定义变量及其默认值
CC = cc                  # C编译器
CXX = g++                # C++编译器
AR = ar                  # 归档工具
RM = rm -f               # 删除命令
MAKE = make              # make命令

# 常用的标志变量
CFLAGS =                 # C编译选项
CXXFLAGS =               # C++编译选项
CPPFLAGS =               # 预处理选项
LDFLAGS =                # 链接器选项
LDLIBS =                 # 链接库

# 使用示例
CFLAGS = -Wall -O2 -Iinclude
LDFLAGS = -Llib
LDLIBS = -lm -lpthread
```

## 7  变量作用域

### 7.1  全局变量

```makefile
# 默认情况下，变量是全局的
GLOBAL_VAR = I am global

target1:
    echo "$(GLOBAL_VAR)"

target2:
    echo "$(GLOBAL_VAR)"
```

### 7.2  目标特定变量

```makefile
# 为目标绑定特定变量
target1: PRIVATE_VAR = For target1 only
target2: PRIVATE_VAR = For target2 only

target1:
    echo "$(PRIVATE_VAR)"  # 输出: For target1 only

target2:
    echo "$(PRIVATE_VAR)"  # 输出: For target2 only

other_target:
    echo "$(PRIVATE_VAR)"  # 输出: (空)
```

### 7.3  模式特定变量

```makefile
# 为匹配模式的目标绑定变量
%.o: CFLAGS = -Wall -O2 -c
%.exe: LDFLAGS = -static

main.o: CFLAGS += -DDEBUG  # 追加模式特定变量

test.o: SPECIAL_FLAG = custom_value

# 示例编译规则
%.o: %.c
    $(CC) $(CFLAGS) $< -o $@
```

## 8  实用示例

### 8.1  完整的 Makefile 示例

```makefile
# 编译器设置
CC = gcc
CXX = g++
CFLAGS = -Wall -O2
CXXFLAGS = -std=c++11 -Wall -O2
LDFLAGS = 
LDLIBS = 

# 目录设置
SRC_DIR = src
OBJ_DIR = obj
BIN_DIR = bin

# 源文件
C_SOURCES = $(wildcard $(SRC_DIR)/*.c)
CPP_SOURCES = $(wildcard $(SRC_DIR)/*.cpp)
SOURCES = $(C_SOURCES) $(CPP_SOURCES)

# 目标文件
C_OBJECTS = $(C_SOURCES:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
CPP_OBJECTS = $(CPP_SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
OBJECTS = $(C_OBJECTS) $(CPP_OBJECTS)

# 最终目标
TARGET = $(BIN_DIR)/app

# 伪目标声明
.PHONY: all clean help

# 默认目标
all: $(TARGET)

# 链接可执行文件
$(TARGET): $(OBJECTS)
    @mkdir -p $(BIN_DIR)
    $(CXX) $(LDFLAGS) $^ -o $@ $(LDLIBS)
    @echo "Build complete: $@"

# 编译C文件
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
    @mkdir -p $(OBJ_DIR)
    $(CC) $(CFLAGS) -c $< -o $@

# 编译C++文件
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp
    @mkdir -p $(OBJ_DIR)
    $(CXX) $(CXXFLAGS) -c $< -o $@

# 清理
clean:
    $(RM) -r $(OBJ_DIR) $(BIN_DIR)

# 帮助信息
define HELP_MESSAGE
Makefile for building $(TARGET)

Usage:
    make [target]

Targets:
    all     - Build everything (default)
    clean   - Remove all build artifacts
    help    - Show this help message
endef

help:
    @echo "$(HELP_MESSAGE)"
```

### 8.2  条件赋值与覆盖示例

```makefile
# 默认优化级别
OPTIMIZATION ?= -O2

# 如果DEBUG已定义，则使用调试标志
ifdef DEBUG
    OPTIMIZATION = -O0 -g
    CFLAGS += -DDEBUG
endif

# 编译器选择（可被命令行覆盖）
CC ?= gcc
CFLAGS += $(OPTIMIZATION) -Wall

# 使用示例
# make                    # 使用-O2优化
# make DEBUG=1            # 使用-O0 -g -DDEBUG
# make CC=clang OPTIMIZATION=-O3  # 使用clang和-O3
```

## 9  最佳实践

1. **使用立即展开（:=）** 除非需要延迟展开的特性
2. **变量名使用大写字母** 以便与命令区分
3. **合理使用目标特定变量** 避免变量污染
4. **充分利用自动变量** 使规则更简洁
5. **使用条件赋值（?=）** 提供合理的默认值
6. **将配置选项集中在文件顶部** 便于修改
7. **使用 override 保护关键变量** 防止意外覆盖
8. **为复杂操作定义多行变量** 提高可读性

## 10  常见问题

### 10.1  变量展开顺序问题

```makefile
# 问题：期望VAR2的值是"expanded"，但实际为空
VAR1 = value
VAR2 := $(VAR1)  # 立即展开，此时VAR1为"value"
VAR1 = expanded

# 解决方案：使用延迟展开或调整定义顺序
VAR1 = expanded
VAR2 := $(VAR1)  # 现在VAR2为"expanded"
```

### 10.2  空格处理问题

```makefile
# 注意：变量值前后的空格会被保留
VAR1 =  value with spaces  
VAR2 := $(strip $(VAR1))  # 使用strip函数去除首尾空格
```

### 10.3  递归展开导致的无限循环

```makefile
# 危险：可能导致无限递归
VAR1 = $(VAR2)
VAR2 = $(VAR1)

# 安全：使用立即展开
VAR1 := $(VAR2)
VAR2 := some_value
```

通过理解这些变量概念，你可以编写出更灵活、可维护的 Makefile 文件。记住，Makefile 变量的核心是**字符串替换**，理解展开时机是掌握它们的关键。
