## 1  最终目标

一个 Makefile 文件通常包含多个目标，但**最终目标（默认目标）** 只有一个。当执行 `make` 命令而不指定具体目标时，就会构建这个最终目标。

### 1.1  默认最终目标

默认情况下，make 会将 **Makefile 中第一条规则的目标** 作为最终目标。

示例：

```makefile
# 第一条规则，main 成为最终目标
main: main.o utils.o
    gcc -o main main.o utils.o

main.o: main.c
    gcc -c main.c

utils.o: utils.c
    gcc -c utils.c
```

### 1.2  手动指定最终目标

可以通过 `.DEFAULT_GOAL` 特殊变量手动指定最终目标：

```makefile
.DEFAULT_GOAL = mytarget

# 即使这条规则在后面，也会作为最终目标
mytarget: dep1 dep2
    echo "Building mytarget"

dep1:
    echo "Building dep1"

dep2:
    echo "Building dep2"
```

## 2  目标文件的更新

make 通过比较目标文件和依赖文件的**最后修改时间**来决定是否需要重新构建目标。

### 2.1  触发更新的条件

只有当满足以下任一条件时，make 才会执行更新目标文件的方法：

1. **目标文件不存在**
2. **目标文件的最后修改时间早于任一依赖文件的最后修改时间**

### 2.2  依赖关系链

make 会递归地检查最终目标的所有直接和间接依赖：

```makefile
# 依赖链：main → main.o → main.c
main: main.o utils.o
    gcc -o main main.o utils.o

main.o: main.c utils.h
    gcc -c main.c

utils.o: utils.c utils.h
    gcc -c utils.c
```

如果 `main.c` 或 `utils.h` 的修改时间比 `main.o` 新，那么 `main.o` 会被重新编译，进而导致 `main` 被重新链接。

### 2.3  手动执行特定目标

与最终目标没有依赖关系的目标需要手动指定执行：

```shell
make clean
make test
```

## 3  伪目标

**伪目标**是不生成实际文件的目标，通常用于执行特定的操作（如清理、安装等）。

### 3.1  定义伪目标

使用 `.PHONY` 关键字声明伪目标：

```makefile
.PHONY: clean install test

clean:
    rm -f *.o main

install:
    cp main /usr/local/bin/

test:
    ./run_tests.sh
```

### 3.2  伪目标的作用

#### 3.2.1  避免与同名文件冲突

如果没有声明为伪目标，且当前目录存在名为 `clean` 的文件，那么执行 `make clean` 时会因为文件已最新而不执行任何操作。

声明为伪目标后，make 会忽略同名文件的存在，始终执行伪目标的命令。

#### 3.2.2  提高性能

声明为伪目标可以告诉 make 不需要检查文件时间戳，提高执行效率。

### 3.3  伪目标的新用法

将生成实际文件的目标声明为伪目标，可以**强制每次重新构建**：

```makefile
.PHONY: generate_version

# 每次都会重新生成版本信息文件
generate_version:
    echo "Version: $(shell date +%Y%m%d)" > version.txt
```

> **注意**：这种做法要谨慎使用，因为它会绕过 make 的正常依赖检查机制。

## 4  特殊目标

Makefile 中有一些特殊目标，它们不是要生成的文件，而是用于改变 make 的行为方式。

### 4.1  `.PHONY`

前面已经介绍，用于声明伪目标。

### 4.2  `.SILENT`

使命令在执行时不显示在终端：

```makefile
.SILENT: clean

# 执行 make clean 时不会显示 rm 命令
clean:
    rm -f *.o
```

更好的做法是在命令前添加 `@`：

```makefile
clean:
    @rm -f *.o
```

### 4.3  `.ONESHELL`

让规则中的所有命令在同一个 shell 进程中执行：

```makefile
.ONESHELL:

multi_step:
    cd src
    ls -la  # 这里还在 src 目录中
```

### 4.4  `.INTERMEDIATE`

声明中间文件，make 会在构建完成后删除这些文件：

```makefile
.INTERMEDIATE: temp_file.o

main: main.o temp_file.o
    gcc -o main main.o temp_file.o

temp_file.o: temp.c
    gcc -c temp.c -o temp_file.o
```

### 4.5  `.SECONDARY`

与 `.INTERMEDIATE` 类似，但不会自动删除这些中间文件。

## 5  编写建议

### 5.1  分离编译和链接

```makefile
# 编译步骤
%.o: %.c
    gcc -c $< -o $@

# 链接步骤
main: main.o utils.o
    gcc -o main main.o utils.o
```

### 5.2  完整声明依赖关系

```makefile
# 不仅要声明源代码依赖，还要声明头文件依赖
main.o: main.c utils.h config.h
    gcc -c main.c -o main.o

utils.o: utils.c utils.h config.h
    gcc -c utils.c -o utils.o
```

### 5.3  使用变量和模式规则

```makefile
CC = gcc
CFLAGS = -Wall -O2
SRCS = main.c utils.c
OBJS = $(SRCS:.c=.o)

.PHONY: all clean

all: main

main: $(OBJS)
    $(CC) $(CFLAGS) -o $@ $^

%.o: %.c
    $(CC) $(CFLAGS) -c $< -o $@

clean:
    rm -f $(OBJS) main
```

## 6  实际示例

```makefile
# 指定最终目标
.DEFAULT_GOAL = all

# 编译器选项
CC = gcc
CFLAGS = -Wall -O2
LDFLAGS = -lm

# 源文件和目标文件
SRCS = main.c math_utils.c io_utils.c
OBJS = $(SRCS:.c=.o)
HEADERS = math_utils.h io_utils.h

# 声明伪目标
.PHONY: all clean rebuild

# 最终目标
all: myapp

# 链接应用程序
myapp: $(OBJS)
    $(CC) $(LDFLAGS) -o $@ $^

# 编译规则
%.o: %.c $(HEADERS)
    $(CC) $(CFLAGS) -c $< -o $@

# 清理
clean:
    rm -f $(OBJS) myapp

# 强制重新构建
rebuild: clean all

# 测试目标
test: myapp
    ./myapp --test

# 安装目标
install: myapp
    install -m 755 myapp /usr/local/bin/
```

## 7  总结

| 概念 | 说明 | 示例 |
|------|------|------|
| **最终目标** | 默认构建的目标 | `.DEFAULT_GOAL = all` |
| **伪目标** | 不生成文件的目标 | `.PHONY: clean` |
| **依赖更新** | 基于时间戳的构建决策 | `目标: 依赖` |
| **特殊目标** | 改变 make 行为的特殊目标 | `.SILENT`, `.ONESHELL` |

**关键要点**：
1. make 基于文件时间戳决定是否需要重新构建
2. 伪目标确保命令始终执行，不受同名文件影响
3. 完整声明依赖关系可以避免隐藏的构建问题
4. 特殊目标提供了对构建过程的细粒度控制
