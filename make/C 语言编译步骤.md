![[C 语言编译过程|1000]]

## 1. 源文件预处理

在 预处理阶段，**预处理器（cpp**）根据以字符 `#` 开头的命令（如 `#include`、`#define` 等），对原始 C 源代码进行操作，生成一个不含预处理指令的 C 语言程序文件，通常以 `.i` 为后缀。

### 1.1. 主要任务

1. **头文件展开**：
	+ 替换 `#include` 指令，将包含的头文件内容插入到对应位置。
2. **宏替换**：
	+ 替换 `#define` 定义的宏为具体值。
	+ 处理条件编译指令（如 `#ifdef`、`#endif`）。
3. **注释删除**：
	+ 删除所有 C 和 C++ 样式的注释（`/* … */` 和 `//`）。
4. **生成纯净的代码**：
	+ 生成预处理后的代码文件（一般为 `.i` 文件），方便后续编译阶段使用。

---

### 1.2. 语法

使用 `gcc` 的 `-E` 选项可以执行预处理，并生成 `.i` 文件。

#### 1.2.1. **基本命令**

```bash
gcc -E input.c -o output.i
```

+ **`-E`**：执行预处理操作，生成预处理后的代码。
+ **`-o`**：指定输出文件的名称，可省略。
	+ 如果省略 `-o` 参数，预处理结果会输出到 **标准输出**（终端）

> [!note]
> `.i` 文件仅供查看或调试，实际编译过程中会自动完成预处理。

### 1.3. 意义

+ 预处理阶段让代码更模块化、易维护。
+ 它将所有外部依赖和宏展开为纯净代码，便于后续的编译和优化。

## 2. 生成汇编语言

生成汇编语言是**将预处理后的代码转换为对应的汇编代码**的阶段。这个阶段由**编译器（as）**完成，结果是一个包含目标平台汇编指令的文件，通常以 `.s` 为后缀。

### 2.1. 主要任务

1. 将预处理后的 C 代码（`.i` 文件）翻译成对应的汇编语言代码。
2. 汇编代码是针对目标平台的低级语言，包含指令集和寄存器操作。
3. 结果便于下一阶段（汇编阶段）将其进一步翻译为机器码。

### 2.2. 语法

使用 `gcc` 的 `-S` 选项可以生成汇编代码，并输出到文件中。

#### 2.2.1. **基本命令**

```bash
gcc -S input.c -o output.s
```

+ **`-S`**：编译到汇编语言阶段，生成汇编代码文件。
+ **`-o`**：指定输出文件的名称（可以省略）。
	+ 如果省略 `-o` 参数，生成的汇编文件默认与源文件同名，后缀为 `.s`。

>[!note]
>+ 使用 `cat`、`less` 等工具查看汇编文件内容
>+ 汇编代码的具体内容取决于目标平台的架构（如 x86、ARM），因此在不同的硬件或交叉编译环境下，生成的代码会有所不同。

### 2.3. 意义

1. **调试和优化**：
	+ 开发者可以**通过汇编代码分析编译器的优化策略或发现代码性能问题**。
2. **低级语言分析**：
	+ 对系统编程或性能关键代码的开发者，生成汇编语言有助于理解代码在硬件上的实际运行方式。
3. **控制编译过程**：
	+ 在需要手动介入汇编语言优化或扩展时，生成 `.s` 文件是一个重要的起点。

## 3. 生成目标文件

将源代码（`.c` 文件）编译为中间的**二进制文件**（目标文件，`.o` 文件）的阶段。

### 3.1. 语法

#### 3.1.1. **单文件编译**

  将 `input.c` 编译为目标文件 `output.o`，供链接阶段使用。

```bash
gcc -c input.c -o output.o
```

+ `-c`：Compile Only，仅编译源文件到目标文件，不执行链接操作。
	+ 适用于大型项目的模块化编译，逐个编译源文件后，再统一链接。
+ `-o`：Output，指定输出目标文件的名称。
	+ 如果省略 `-o`，则默认目标文件名与源文件名相同，后缀变为 `.o`。

#### 3.1.2. **多文件编译**

+ 编译所有的 `.c` 文件，分别生成与源文件同名的目标文件，后缀为 `.o`。

```bash
gcc -c input1.c input2.c
```

  + `-c` 选项会为每个输入源文件生成独立的目标文件，无法将多个源文件合并为一个目标文件。

### 3.2. 意义

1. **模块化开发**：
   + 目标文件允许分离编译和链接阶段，便于协作开发。

2. **提升编译效率**：
   + 只重新编译修改过的源文件，无需重新编译整个项目。

3. **可重复使用**：
   + 目标文件可以单独分发，供其他程序链接使用。

## 4. 生成可执行文件

**链接阶段**是将多个目标文件（`.o` 文件）以及库文件合并生成一个可执行文件的关键步骤。

### 4.1. 主要任务

1. 解析和匹配目标文件之间的未定义符号。
2. 合并各个目标文件的代码段、数据段等内容。
3. 加载需要的静态库或动态库。
4. 生成一个可以在操作系统环境中运行的可执行文件。

### 4.2. 语法

#### 4.2.1. **直接编译源文件并链接**

```bash
gcc input1.c input2.c -o exec
```

+ **`gcc`**：调用编译器，同时执行编译和链接。
+ **`input1.c input2.c`**：源文件，编译后自动生成对应的 `.o` 文件。
+ **`-o exec`**：指定输出文件名为 `exec`。

#### 4.2.2. **分步编译和链接**

```bash
gcc -c input1.c -o input1.o
gcc -c input2.c -o input2.o
gcc input1.o input2.o -o exec
```

+ **`-c`**：仅生成目标文件，不链接。
+ **`input1.o input2.o`**：将目标文件输入到链接器。
+ **`-o exec`**：指定生成的可执行文件名。

## 5. 目标文件和库文件的链接

### 5.1. 静态链接

静态库的创建过程通常使用 `ar` 工具，它将多个目标文件（`.o`）打包为一个静态库文件（`.a`）。

#### 5.1.1. 创建静态库

```bash
ar -r [lib自定义库名.a] [目标文件.o] [目标文件.o] ...
```

+ **`ar`**：工具用于创建、修改、提取库文件。
+ **`-r`**：插入文件到库中。如果库已经存在，则更新库中的目标文件。
+ **`lib自定义库名.a`**：静态库文件的名称，通常以 `lib` 开头，`.a` 作为扩展名（例如 `libmylib.a`）。
+ **`[目标文件.o]`**：要打包到静态库中的目标文件（`.o` 文件）。

#### 5.1.2. 查看库文件内容

使用 `ar -t` 查看库文件中的内容

```shell
ar -t lib自定义库名.a
```

+ 输出将显示库中包含的所有目标文件

#### 5.1.3. 在程序中链接静态库

将目标文件链接成执行文件时，也可以链接库文件。

```shell
gcc main.c -L/path/to/library -lexample -o exec
```

+ **`-L/path/to/library`**：指定库的路径。如果库位于当前目录，`-L.` 即可。
+ **`-lexample`**：指定要链接的库。`-l` 后面跟库的名称，省略 `lib` 和 `.a` 后缀。即 `libexample.a` 被指定为 `-lexample`。
+ **`-o exec`**：指定输出的可执行文件名为 `exec`。

### 5.2. 动态链接

在 C 编程中，**动态链接**使用动态库（`.so` 文件），生成的可执行文件在运行时需要依赖这些外部库。通过使用动态库，可以在多个程序之间共享代码，减少内存占用并简化程序的更新。

#### 5.2.1. 什么是动态库（`.so` 文件）

+ **`.so`**：共享对象文件（Shared Object），相当于 Windows 下的 `.dll` 文件。
+ 在程序运行时，动态库会被加载，而不是像静态库一样在编译时嵌入到可执行文件中。
+ 动态库可以被多个程序共享，节省磁盘空间和内存。

#### 5.2.2. 什么是动态链接

+ 在编译时，编译器通过指定动态库的位置将相关的符号（如函数、变量）链接到可执行文件。
+ 在程序运行时，操作系统会从系统的库路径中加载并链接动态库。

#### 5.2.3. 动态库搜索路径

1. **在编译时**：通过 `-L` 选项指定动态库的搜索路径。
2. **在运行时**：

	+ 系统会查找环境变量 `LD_LIBRARY_PATH` 指定的路径。
	+ 在 Linux 上，`LD_LIBRARY_PATH` 环境变量用于指定动态库的查找路径。可以通过以下命令设置该变量：

		```shell
		 LD_LIBRARY_PATH=/path/to/libs:$LD_LIBRARY_PATH
		 ```

3. **系统默认路径**：
	+ 默认情况下，动态库也会在 `/lib` 和 `/usr/lib` 等标准路径下查找。

#### 5.2.4. 创建动态库

##### 编译二进制 .o 文件

```shell
gcc -c -fPIC -shared [.c/.cpp] [.c/.cpp] ...
```

+ **`-fPIC`**：生成位置独立代码（Position Independent Code），这是创建动态库时的要求。

##### 编库

```bash
gcc -shared [.o] [.o] ... -o libmylib.so 
```

+ **`-shared`**：指示编译器生成共享库文件。
+ **`libmylib.so`**：生成的动态库文件。

#### 5.2.5. 链接动态库到可执行文件

```bash
gcc [.o] -L/path/to/libs -lmylib -o exec
```

+ `-L`：指定动态库的搜索路径，告诉编译器在哪里找到 `.so` 文件。
	+ `/path/to/libs`：库文件目录。
+ `-l`：指定动态库名称，告诉编译器动态库的名称是什么。
	+ `mylib`：动态库名。`libmylib.so`去掉 `lib` 前缀和 `.so` 后缀，只保留`mylib`。

>[!note]
>编译时使用 **`-L`** 和 **`-l`** 选项指定库文件位置和名称。
