## 4.1 基础

**表达式**由一个或多个**运算对象**组成，对表达式求值将得到一个**结果**

字面值和变量为最简单的表达式，其结果也就是字面值和变量本身

### 4.1.1 基本概念

#### n 元运算符

有n个运算对象的运算符叫做n元运算符

C++ 定义了一些一元运算符、二元运算符和三元运算符

#### 运算对象转换

不同的运算对象之间的运算，会发生类型的自动转换[[2 C++内置数据类型#2.1.2 类型转换]]

#### 重载运算符

C++允许对运算符的自定义

+ 运算对象的类型和返回值的类型由运算符决定
+ 运算对象的个数、运算符的优先级和结合律无法改变
+ 因此用于其实能改变的只有运算对象的内容和运算规则

#### 左值和右值

+ 当一个对象被用作右值时，用的是对象的值（内容）
+ 当一个对象被用作左值时，用的对象的身份（内存地址）
+ 左值可以被用成右值使用，用的是对象的值
+ 右值不能被当成左值使用

> 左值可以被当作右值，因为从内存地址可以取出值
> 右值不可以被当作左值，因为从值中无法确定该值对应的内存地址
> 比如，你看到一个地址，那么你可以根据该地址找到住那的人
> 但你看到一个人，却无法知道其住在哪

### 4.1.2 运算优先级和运算结合律

复合表达式：指含有两个或多个运算符的表达式

**优先级**和**结合律**决定了运算对象组合的方式

+ **高优先级**运算符的运算对象要比低优先级运算符的运算对象更为紧密地组合在一起
+ 优先级相同的情况下，则其组合规则由结合律确定。算术运算符满足**左结合律**，意味着如果运算符的优先级相同，将按照**从左向右**的顺序组合运算对象
+ **括号**无视普通的组合规则，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合

优先级和结合律会影响结果的正确性

运算符优先级表在 **p 147页**

### 4.1.3 求值顺序

GG

优先级规定了运算对象的组合方式，但没有说明运算对象按照什么顺序求值。在大多情况下，不会明确指定求值的顺序

>[!warning] 没有指定执行顺序的运算符，修改同一对象
>+ 对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。
>+ 有点像数据库幻读，也就是同时对同一对象进行了不同的操作，因此，应避免

>[!advance] 处理复合表达式
>1. 拿不准的时候最好用**括号**来强制让表达式的组合关系符合逻辑的要求
>2. 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象
>3. 当改变运算对象的子表达式本身是另一个的子表达式的运算对象时，第2条无效

> + 建议的第2条就是说，不要同时对某一个对象进行不知道顺序的多个不同操作
> + 算术运算符具有左结合律，因此，是有执行顺序的

## 4.2 算术运算符

| 运算符 | 功能   | 用法            | 优先级 |
| --- | ---- | ------------- | --- |
| +   | 一元正号 | $+ expr$      | 0   |
| -   | 一元负号 | $-expr$       | 0   |
| *   | 乘法   | $expr * expr$ | 1   |
| /   | 除法   | $expr / expr$ | 1   |
| %   | 求余   | $expr\%expr$  | 1   |
| +   | 加法   | $expr + expr$ | 2   |
| -   | 减法   | $expr-expr$   | 2   |

+ 优先级高的运算符比优先级低的运算符组合的更加紧密
+ 算术运算符满足左结合律，优先级相同时，按照从左向右的顺序组合
+ 算术运算符通常能作用于任意**算术类型**和任意能转换为算术类型的类型
+ 算术运算符的运算对象和结果都是**右值**

一元正号运算符、加法运算符和减法运算符都能作用于指针。

### 一元正号运算符和一元负号运算符

一元正号运算符作用于一个指针或算术值时，返回运算对象值的一个（提升后的）副本

一元负号运算符对运算对象取负后，返回运算对象值的一个（提升后的）副本

```C++
int i = 1024;
int k = -i; // k = -1024
```

> 所谓提升后的，也就是在进行算术运算时，参与运算的对象会根据运算进行类型转换
> 这里获得的副本是类型提升后的对象的副本

### 加法运算符和减法运算符作用于指针

+ 加法运算符：
	+ 指针+ 整数：得到整数距离后的另一个指针
+ 减法运算符
	+ 指针 - 整数：得到整数距离前的另一个指针
	+ 指针 - 指针：得到指针之间的距离

### 布尔类型的运算对象不应该参与运算

```C++
bool b = true;
bool b2 = -b; // b2 为 true
```

对大多数运算符，bool 运算对象会被提升为 int 类型。比如上述代码中，

+ `-b`，这里的 b 将会被提升为 `int b = 1`。
+ 得到`-b = -1`。
+ `bool b2 = -1`，int 类型转换为 bool 类型，0为false，其他为true
+ 因此，`b2 = true`

>[!note] 溢出和其他算术运算异常
>算术表达式可能产生未定义的结果
>+ 数学性质本身：除数是0
>+ 计算机的特点：
>	+ 溢出：当计算的结果超出该类型所能表示的范围时

### 除法

整数相除得到的结果仍然是整数。如果商还有小数部分，将直接舍弃

### 取余运算

```C++
res = m%n
```

+ 参与运算的运算对象必须是整数
+ n 非 0
+ 如果 `m%n` 不等于 0，则其符号和m相同

## 4.3 逻辑和关系运算符

关系运算符作用于算数类型或指针类型

逻辑运算符作用于任意能转换成布尔值的类型

| 结合律 | 运算符  | 功能   | 用法               | 优先级 |
| --- | ---- | ---- | ---------------- | --- |
| 右   | !    | 逻辑非  | `!expr`          | 0   |
| 左   | <    | 小于   | `expr < expr`    | 1   |
| 左   | <=   | 小于等于 | `expr <= expr`   | 1   |
| 左   | >    | 大于   | `expr > expr`    | 1   |
| 左   | >=   | 大于等于 | `expr >= expr`   | 1   |
| 左   | ==   | 相等   | `expr == expr`   | 2   |
| 左   | !=   | 不相等  | `expr != expr`   | 2   |
| 左   | &&   | 逻辑与  | `expr && expr`   | 3   |
| 左   | \|\| | 逻辑或  | `expr \|\| expr` | 4   |

**短路求值**：逻辑与运算符和逻辑或运算符是**先求左侧运算对象的值再求右侧对象的值**，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。
+ 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值
+ 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值

```C++
if(val) // 如果 val == 0 为 false；否则，为 true

if(val == true) // 如果 val 并非布尔值，则 true 会先转换为 val 的类型
				// 如果 val 是int，则相当于 if(val == 1)
				// 而这个和 if(val) 并不相同
```

> [!warning] 进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象

>[!note] 相等性运算
>相等性运算未定义求值顺序

## 4.4 赋值运算符

赋值运算符的左侧运算对象必须是一个可修改的左值

赋值运算的结果是它的左侧运算对象，并且是一个左值。结果的类型为其左侧运算对象的类型。如果赋值运算左右两侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。

### 列表初始化右侧对象允许为初始值列表

**窄化转换**：当右侧运算对象为初始值列表时，如果左右两侧运算对象类型不同，当右侧对象向左侧对象发生类型转换，且右侧对象存在信息损失时，报错。

左侧对象为内置类型时，初始值列表最多只能包含一个值。

左侧对象为类类型时，赋值行为由类本身定义。

无论左侧运算对象是什么，初始值列表都可以为空。

### 赋值运算符满足右结合律

### 赋值运算符优先级较低

>[!note] 因为赋值运算符的优先级低于关系运算符，所以在条件语句中，赋值部分通常应该加上括号

### 复合赋值运算符

```C++
a op= b;
// 等价于
a = a op b;
```

上述两个代码中唯一的区别就是左侧运算对象的求值次数

+ `a op= b`，只求值一次
+ `a = a op b`，需要求值两次，首先是右侧子表达式的求值，然后是赋值运算

## 4.5 递增和递减运算符

```C++
++v; // 前置递增
v++; // 后置递增
--v; // 前置递减
v--; // 后置递减
```

+ 递增和递减运算符必须作用于左值运算对象
+ 前置将运算对象本身作为左值返回
+ 前置返回的值为递增之后的值
+ 后置将对象原始值的副本作为右值返回
+ 后置返回的值为递增之前的值

> [!advace] 除非必须，否则不用递增递减运算符的后置版本

```C++
auto pbeg = v.begin();
while(pbeg!= v.end() && *beg >= 0)
	cout << *pbeg++ << endl;
```

+ 后置运算符的优先级高于解引用运算符，因此`*pbeg++`<->`*(pbeg++)`

> [!warning] 注意运算顺序
> 由于递增运算符和递减运算符会修改运算对象的值，因此要提防在复合表达式中错用这两个运算符
> 如`*pbeg = *pbeg++;`
>
>+ 由于`=`运算符，并未规定左右运算对象的运算顺序，也就是说，有可能是先左后右，也有可能是先右后左
>+ 同时，`=`运算符的左右运算对象都使用了`pbeg`，并且右侧运算对象还改变了`pbeg`的值
>+ 因此，该语句是未定义的。

## 4.6 成员访问运算符

### 点运算符

获取类对象的一个成员

当成员所属对象是左值时，其结果也是左值。反之，为右值。

### 箭头运算符

`ptr -> men` <-> `(*ptr).men`

> 解引用运算符的优先级，低于点运算符

作用于一个指针类型的运算对象

结果为左值

## 4.7 条件运算符

语法

`cond ? expr1 : expr2;`

如果cond为真，对expr1进行计算，并返回结果；否则，对expr2进行计算，并返回结果

当条件运算符的两个表达式都是左值，或者能转换成同一种左值类型时
