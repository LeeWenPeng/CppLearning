## 1 背景

- 除了 0 号进程，其他的所有进程无论是内核线程还是普通的用户线程都是 fork 出来的
- 创建进程是内核的职责
	- 在内核空间：可以直接创建内核线程
	- 在用户空间：通过 fork、clone 等系统调用，陷入到内核空间来创建
- 内核线程之间切换不需要进行地址空间转换
	- 内核空间由所有进程共享
- 用户进程和用户线程，与内核线程之间的切换需要异常级别的切换

## 2 fork 进程写时复制的机制

写时复制（Copy-on-Write，COW）是 fork 进程中的一种优化机制。fork 创建子进程时，并不立即复制父进程的物理内存，而是让父子进程共享相同的物理内存页，并将这些页面标记为只读。只有当某个进程（父或子）试图修改共享页面时，内核才为该进程复制一个新的物理页面，并修改相应的页表映射。这种方式显著减少了 fork 的开销，特别是当父进程有大量内存时。

## 3 从内存管理阐述

### 3.1 子进程如何构建自己的内存管理相关基础设施

子进程通过以下步骤构建内存管理基础设施：

1. **创建 task_struct**：内核为子进程分配新的 task_struct 结构体，这是进程的 " 身份证 "。

2. **复制 mm_struct**：
   - 内核创建子进程自己的 mm_struct，这是进程地址空间的 " 管理者 "。
   - 复制父进程的 mm_struct 中的核心信息，如代码段、数据段、堆栈段等布局。

3. **复制 vma 链表**：
   - 遍历父进程的 vma 链表，为每个 vma 创建子进程的副本。
   - 新的 vma 结构与父进程的 vma 描述相同的虚拟地址范围，但指向相同的物理页面。

4. **复制页表**：
   - 创建子进程的页表目录（PGD），但只复制页表目录项，而不复制底层页表。
   - 设置写保护标志，为后续 COW 做准备。

### 3.2 父子进程如何共享地址空间

1. **vma 共享**：
	- 子进程的 vma 描述与父进程完全相同的虚拟地址范围，包括代码段、数据段、堆、栈等。
	- 这些 vma 指向相同的物理页面，实现了物理内存的共享。

2. **页表设置与写保护**：
	- 为子进程分配了页表目录，而且为其设置写保护标志。
	- 当触发写保护时，进行写操作的进程分配新的物理页，并更新页表映射。

```cpp
   初始状态：
   父进程页表：虚拟页A → 物理页X（可读写）
   子进程页表：虚拟页A → 物理页X（只读）
   
   当子（父）进程尝试写入页A时：
   3. 检查发现页表项标记为只读（但vma标记为可写）
   4. 触发写保护异常
   5. 分配新的物理页Y
   6. 复制物理页X的内容到物理页Y
   7. 更新子进程页表：虚拟页A → 物理页Y（可读写）
   8. 父进程页表保持不变：虚拟页A → 物理页X（只读）
   ```

![写时复制技术*1000](写时复制技术以及fork的细节/写时复制技术.md)

### 3.3 页表层面为用户做了什么事情

1. **延迟分配**：
   - 在 fork 时，内核仅分配顶级页表目录（PGD），不分配中间页表和页表项。
   - 当进程首次访问某个虚拟地址时，触发缺页异常，内核才逐级分配页表结构。

2. **写保护标记**：
   - 内核将共享页的页表项标记为只读，即使对应的 vma 标记为可写。
   - 这种不一致性是触发 COW 的关键机制。

3. **缺页异常处理**：
   - 当进程访问尚未映射的虚拟页时，触发缺页异常。
   - 异常处理程序根据缺页原因（未映射、写保护、页面不在内存等）进行相应处理。

### 3.4 写时复制如何发生

1. **触发条件**：
   - 进程尝试写入一个标记为只读但 vma 标记为可写的页面。
   - CPU 触发写保护异常（缺页异常的一种）。

2. **写保护异常处理流程**：
   1. 检查异常地址是否在进程的地址空间内
   2. 检查对应的 vma 是否具有可写权限
   3. 检查页表项是否标记为只读
   4. 检查该物理页的引用计数
      - 如果引用计数=1，说明没有其他进程共享，只需修改页表项为可写
      - 如果引用计数>1，说明有进程共享，需要执行 COW
   5. 执行 COW：
      a. 分配新的物理页面
      b. 复制原页面内容到新页面
      c. 更新当前进程的页表项，指向新页面并标记为可写
      d. 减少原物理页面的引用计数
   6. 返回用户空间，重新执行导致异常的写指令

3. **内核中的关键判断**：
   - 在缺页异常处理函数中，内核检查：

     ```c
     if (页表项存在 && 页表项只读 && vma可写) { // 写保护错误
         // 触发COW
         if (物理页引用计数 > 1) {
             执行COW流程();
         } else {
             只需修改页表项为可写();
         }
     }
     ```

4. **性能优势**：
   - 如果 fork 后立即执行 exec，子进程加载新程序，共享的页面会被新程序的页面替换，避免了不必要的复制。
   - 对于只读页面（如代码段），永远不需要复制，父子进程始终共享。
