## 1  只能在堆上创建对象的类

### 1.1  基本原理与设计思路

核心目标：防止对象在栈上或数据段中分配，只能通过 `new` 在堆上创建。

**关键技术点**：
1. **构造函数控制**：防止直接栈上构造
2. **析构函数控制**：防止编译器自动调用析构
3. **拷贝/移动控制**：防止通过拷贝在栈上创建副本
4. **内存释放控制**：确保安全销毁

### 1.2  各方案对比与优化

#### 1.2.1  **方案一：私有构造函数 + 静态工厂函数** ✅ **推荐**

```cpp
class HeapOnlyV1 {
public:
    // 禁止拷贝构造和拷贝赋值
    HeapOnlyV1(const HeapOnlyV1&) = delete;
    HeapOnlyV1& operator=(const HeapOnlyV1&) = delete;
    
    // 禁止移动构造和移动赋值（可选，增强限制）
    HeapOnlyV1(HeapOnlyV1&&) = delete;
    HeapOnlyV1& operator=(HeapOnlyV1&&) = delete;
    
    // 静态工厂函数
    static HeapOnlyV1* create() {
        return new HeapOnlyV1();
    }
    
    // 必须提供显式销毁方法
    void destroy() {
        delete this;
    }

private:
    HeapOnlyV1() = default;
    ~HeapOnlyV1() = default;
};
```

**优化要点**：
1. 明确删除所有拷贝和移动操作
2. 提供明确的销毁接口
3. 私有化默认析构函数，防止通过 `delete` 直接删除

#### 1.2.2  **方案二：仅私有析构函数**

```cpp
class HeapOnlyV2 {
public:
    HeapOnlyV2() = default;
    
    // 显式删除拷贝和移动（可选但建议）
    HeapOnlyV2(const HeapOnlyV2&) = delete;
    HeapOnlyV2& operator=(const HeapOnlyV2&) = delete;
    
    // 销毁接口
    void destroy() {
        delete this;  // 合法：成员函数可以调用私有析构
    }

private:
    ~HeapOnlyV2() = default;
};
```

**注意事项**：
- 派生类可能绕过限制（如果析构函数不是虚函数）
- 仍然可以在栈上创建，但编译器会在析构时报错（编译期发现问题）

#### 1.2.3  **方案三：智能指针管理（现代 C++ 推荐）** ⭐ **最佳实践**

```cpp
#include <memory>
#include <type_traits>

class HeapOnlyModern {
public:
    // 禁止拷贝
    HeapOnlyModern(const HeapOnlyModern&) = delete;
    HeapOnlyModern& operator=(const HeapOnlyModern&) = delete;
    
    // 允许移动（如果需要）
    HeapOnlyModern(HeapOnlyModern&&) noexcept = default;
    HeapOnlyModern& operator=(HeapOnlyModern&&) noexcept = default;
    
    // 工厂函数返回unique_ptr
    static std::unique_ptr<HeapOnlyModern> create() {
        // 使用自定义删除器绕过私有析构限制
        struct Deleter {
            void operator()(HeapOnlyModern* p) const {
                delete p;
            }
        };
        return std::unique_ptr<HeapOnlyModern, Deleter>(new HeapOnlyModern());
    }
    
    // 工厂函数返回shared_ptr
    static std::shared_ptr<HeapOnlyModern> createShared() {
        // 使用lambda作为自定义删除器
        auto deleter = [](HeapOnlyModern* p) { delete p; };
        return std::shared_ptr<HeapOnlyModern>(new HeapOnlyModern(), deleter);
    }

private:
    HeapOnlyModern() = default;
    ~HeapOnlyModern() = default;
    
    // 允许自定义删除器访问私有析构（如果使用外部删除器）
    template<typename T, typename Deleter>
    friend class std::unique_ptr;
};
```

**优势**：
1. 自动内存管理，无泄漏风险
2. 清晰的资源所有权语义
3. 兼容现代 C++ RAII 原则

#### 1.2.4  **方案四：使用 `std::make_unique` 的变体（C++14+）**

```cpp
class HeapOnlyWithMake {
public:
    template<typename… Args>
    static std::unique_ptr<HeapOnlyWithMake> make(Args&&… args) {
        // 使用protected构造函数允许make_unique访问
        struct EnableMake : public HeapOnlyWithMake {
            EnableMake(Args&&… args) 
                : HeapOnlyWithMake(std::forward<Args>(args)…) {}
        };
        return std::make_unique<EnableMake>(std::forward<Args>(args)…);
    }
    
    // 其他成员函数…

protected:
    // protected构造函数允许派生类调用
    HeapOnlyWithMake() = default;
    ~HeapOnlyWithMake() = default;

private:
    HeapOnlyWithMake(const HeapOnlyWithMake&) = delete;
    HeapOnlyWithMake& operator=(const HeapOnlyWithMake&) = delete;
};
```

## 2  只能在栈上创建对象的类

### 2.1  完整实现方案

```cpp
#include <cstddef>
#include <new>

class StackOnly {
public:
    StackOnly() = default;
    
    // 允许拷贝和移动（栈对象的特性）
    StackOnly(const StackOnly&) = default;
    StackOnly& operator=(const StackOnly&) = default;
    StackOnly(StackOnly&&) = default;
    StackOnly& operator=(StackOnly&&) = default;
    
    // 禁止所有堆分配方式
    void* operator new(size_t) = delete;
    void* operator new[](size_t) = delete;
    void* operator new(size_t, void*) = delete;  // placement new
    void* operator new[](size_t, void*) = delete;
    
    // 禁止对应delete操作符
    void operator delete(void*) = delete;
    void operator delete[](void*) = delete;
    void operator delete(void*, void*) = delete;
    void operator delete[](void*, void*) = delete;
    
    // 禁止通过malloc创建（额外保护）
    void* operator new(size_t, const std::nothrow_t&) = delete;
    void* operator new[](size_t, const std::nothrow_t&) = delete;
};
```

### 2.2  防止绕过的额外措施

```cpp
class StrictStackOnly {
public:
    StrictStackOnly() {
        // 运行时检查：确保对象在栈上
        checkStackAllocation();
    }
    
    ~StrictStackOnly() = default;
    
    // 删除所有堆分配操作符
    void* operator new(size_t) = delete;
    void* operator new[](size_t) = delete;
    // … 同上
    
private:
    void checkStackAllocation() {
        // 简单检查：比较当前栈指针和对象地址
        // 注意：这只是一个示例，实际实现需要考虑平台差异
        int dummy;
        void* stackAddr = &dummy;
        void* thisAddr = this;
        
        // 计算大致距离，判断是否在栈上
        // 实际工程中需要更严谨的实现
    }
};
```
