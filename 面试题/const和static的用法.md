## 1  const 关键字

`const` 的核心作用是定义 " 常量 " 或指定 " 不可变性 "。

### 1.1  修饰变量

- **作用**：变量值在初始化后不能再被修改。
- **本质**：在编译阶段保证该变量（对象）的只读属性。
- **示例**：

  ```cpp
  const int MAX_SIZE = 100;
  // MAX_SIZE = 200; // 错误：不能修改 const 变量
  ```

### 1.2  修饰指针

- **常量指针 (Pointer to Constant)**：
  - 声明：`const Type* ptr` 或 `Type const* ptr`
  - **含义**：不能通过该指针修改其指向对象的值，但指针本身可以指向其他地址。
  - **记忆**：`const` 在 `*` 左边，表示指向的对象是常量。

  ```cpp
  int a = 10, b = 20;
  const int* p = &a;
  // *p = 30; // 错误：不能通过 p 修改 a 的值
  p = &b;     // 正确：指针本身可以修改
  ```

- **指针常量 (Constant Pointer)**：
  - 声明：`Type* const ptr`
  - **含义**：指针的指向（地址）不能修改，但可以通过该指针修改其指向对象的值。
  - **记忆**：`const` 在 `*` 右边，表示指针本身是常量。

  ```cpp
  int a = 10, b = 20;
  int* const p = &a;
  *p = 30;    // 正确：可以通过 p 修改 a 的值
  // p = &b;  // 错误：指针的指向不能修改
  ```

- **指向常量的指针常量**：
  - 声明：`const Type* const ptr`
  - **含义**：指针的指向和指向对象的值都不能修改。

  ```cpp
  const int* const p = &a;
  ```

### 1.3  修饰引用

- **常量引用 (Reference to Constant)**：
  - 声明：`const Type& ref`
  - **含义**：不能通过该引用修改其绑定的对象的值。
  - **重要特性**：常量引用可以绑定到常量、非常量、甚至字面值和表达式（会产生临时对象）。

  ```cpp
  int x = 5;
  const int& r1 = x;  // 绑定到非常量变量
  const int& r2 = 10; // 绑定到字面值
  // r1 = 20; // 错误：不能通过常量引用修改值
  ```

### 1.4  修饰成员函数

- **作用**：该成员函数承诺不会修改调用它的对象的任何非静态成员变量（除非成员被 `mutable` 修饰）。
- **语法**：在函数声明和定义的参数列表后加上 `const`。
- **本质**：它修改了成员函数中隐含的 `this` 指针类型，使其从 `Type* const this` 变为 `const Type* const this`。
- **示例**：

  ```cpp
  class MyClass {
      int value;
  public:
      int getValue() const { // 常量成员函数
          // value = 10; // 错误：不能修改成员变量
          return value;
      }
      void setValue(int v) { // 非常量成员函数
          value = v;
      }
  };
  const MyClass obj;
  // obj.setValue(5); // 错误：常量对象只能调用常量成员函数
  int x = obj.getValue(); // 正确
  ```

### 1.5  this 指针补充

- **默认类型**：在**非 const 成员函数**中，`this` 的类型是 `ClassName* const this`（指针常量）。
- **在 const 成员函数中**：`this` 的类型是 `const ClassName* const this`（指向常量的指针常量）。
- **传递机制**：当调用成员函数时，对象的地址作为实参隐式地传递给 `this` 形参。这通常通过寄存器或栈来传递，并非对象自身存储。

---

## 2  static 关键字

`static` 的关键在于改变标识符的**存储周期（生命周期）**、**链接属性**和**作用域**。

### 2.1  在 C 语言及 C++ 的面向过程部分

1. **静态局部变量**
    - **作用域**：函数内部（与局部变量相同）。
    - **生命周期**：从首次执行到其定义处初始化开始，直到整个程序结束（不同于局部变量的 " 函数调用期 "）。
    - **关键特性**：**只初始化一次**，函数调用结束后其值被保留。
    - **存储区域**：全局/静态数据区。

    ```c
    void func() {
        static int count = 0; // 只初始化一次
        count++;
        printf("%d\n", count);
    }
    ```

2. **静态全局变量/函数**
    - **作用**：限制其**链接属性**为**内部链接**。
    - **效果**：使得该变量或函数的作用域仅限于定义它的源文件（翻译单元）内，对其他源文件不可见。
    - **目的**：
        1. **隐藏**：避免命名空间污染。
        2. **封装**：实现文件内部的私有化。

### 2.2  在 C++ 的面向对象部分（类中）

1. **静态成员变量**
    - **归属**：属于类本身，而不是类的任何一个对象。所有类对象共享同一份静态成员变量。
    - **存储**：存储在全局数据区，不占用类对象的内存空间。
    - **初始化**：必须在**类外**（通常是在源文件中）单独进行定义和初始化（分配存储空间）。类内的声明只是告诉编译器该变量的存在和类型。
    - **访问**：可以通过类名 (`ClassName::staticVar`) 或对象来访问，受类访问权限控制。

    ```cpp
    class MyClass {
    public:
        static int sharedCount; // 声明
    };
    int MyClass::sharedCount = 0; // 定义并初始化（必须）
    ```

2. **静态成员函数**
    - **归属**：属于类本身，而非特定对象。
    - **调用**：无需创建类的实例，即可通过类名调用（`ClassName::staticFunc()`）。
    - **关键限制**：
        - **没有 `this` 指针**：因为不与任何对象绑定。
        - **只能直接访问类的静态成员（变量/函数）**，不能直接访问非静态成员（因为非静态成员必须通过对象来访问）。
    - **用途**：常用于操作静态成员变量，或执行与类相关但不依赖于对象状态的任务（如 " 工厂方法 "）。

    ```cpp
    class MyClass {
        static int staticVar;
        int nonStaticVar;
    public:
        static void staticFunc() {
            staticVar = 10; // 正确
            // nonStaticVar = 20; // 错误：不能直接访问非静态成员
        }
    };
    ```

---

### 2.3  总结对比

| 特性 | `const` | `static` |
| :--- | :--- | :--- |
| **核心思想** | **不变性** (Immutable) | **持久性与归属** (Persistence & Ownership) |
| **主要作用** | 保护数据不被意外修改，增强代码安全性和可读性。 | 改变生命周期、链接属性；实现类的共享成员和工具函数。 |
| **关键点** | 是一个类型限定符。 | 是一个存储类说明符。 |
| **与对象关系** | 可以修饰对象本身、对象指针/引用，以及成员函数（承诺不修改对象状态）。 | 静态成员属于类，与对象实例无关。 |

**实际应用提示**：
- **`const`** 用于函数参数、返回值、成员函数，是编写健壮接口和实现**常量正确性**的关键。
- **`static`** 用于实现单例模式、管理类级别数据、工具函数，以及控制文件内部的可见性。
