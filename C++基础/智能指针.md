## 1  概述

智能指针是 C++ 中的类模板，它们通过 RAII 模式自动管理动态分配的内存，防止内存泄露。

## 2  为什么需要智能指针

### 2.1  传统指针存在的问题

传统指针需要手动释放，因此

1. 内存泄露：当动态分配的内存未被正确释放，就会造成内存泄露
2. 空悬指针/野指针：指针指向的内存已被释放，但指针本身未被置空
3. 指针悬挂：多个指针指向同一个内存区域，其中一个指针释放内存后，其他指针成为悬挂指针。
4. 重复释放：同一块内存被释放多次，引发 coredump
5. 资源管理不匹配：分配和释放方式不匹配

### 2.2  智能指针的解决思路

#### 2.2.1  RAII 思想

- 资源获得即初始化：在构造函数中获取资源
- 资源释放自动化：在析构函数中释放资源
- 异常安全：即使发生异常，也能保证资源被正确释放

#### 2.2.2  智能指针的实现原理

- 智能指针本质上是包装了原始指针的类，通过重载运算符和利用析构函数自动管理资源
- 自动释放内存：智能指针退出作用域后，在栈上自动调用析构函数

## 3  std::auto_ptr(已废弃)

- 不能**复制和赋值**
- 但，代码中如果有复制和复制操作时，编译也报错
- 因为不能复制，因此不能存放在容器中

## 4  std::unique_ptr

- **独占所有权**，不能复制和赋值
- 但，如果代码中有赋值操作，编译会报错（比 auto_ptr 先进的地方）
- 提供了移动构造和移动赋值
- 可以通过 std::move() 实现所有权转移

```cpp
std::unique_ptr p1(new int(5));
std::unique_ptr p2 = p1; // 会报错
std::unique_ptr p3 = std::move(p1);
// std_move 将 p1 的内存所有权转移给 p3
// p1 会失效
```

### 4.1  不能拷贝，但是允许函数返回 unique_ptr

- 编译器的优化
- 函数返回临时的原理
	- 如果有移动构造，就调用移动构造
	- 如果有拷贝构造，就调用拷贝构造
	- 没有拷贝构造，则报错

### 4.2  不能拷贝，但是允许移动

unique_ptr 可以通过 std::move 来转移所有权

```cpp
unique_ptr<T> ptr1(new T);
unique_ptr<T> ptr2 = std::move(ptr1);
// 1. ptr1就不再拥有 new T 返回指针的所有权，其转移给 ptr2
```

### 4.3  推荐使用 make_unique（C++14）

- 使用 new 版本初始化重复了被创建对象的键入，违背了软件工程的一个重要原则：应该避免代码重复，代码中的重复会引起编译次数的增加，导致目标代码膨胀。
- 使用 make_unique 则避免了该问题

> [!tip] 注意
> - std::make_unique 是 C++14 后才支持的
> - unique_ptr 和 shared_ptr 不能混用

### 4.4  unique_ptr 可以指向数组

```cpp
std::unique_ptr<int []> ptr(new int[10]);
ptr[9] = 9;

// std::shared_ptr<int []> ptr2(new int[10]); // 非法
```

## 5  std::shared_ptr

- 基于**引用次数**的智能指针
- 多个指针可以共享同一对象
- 当引用次数为 0 时，才会被真正的释放掉
- 可以随意复制和赋值

### 5.1  指向

shared_ptr 的实现包含两部分

- 一个指向堆上创建对象的裸指针
- 一个指向内部隐藏的、共享的管理对象

![shared_ptr指向*1000](智能指针/shared_ptr指向.md)

### 5.2  释放内存

1. 当 std::shared_ptr 退出作用域后，就会调用析构函数，然后 ref_count -= 1

### 5.3  场景

- 容器中使用指针
- 资源通过函数传递

### 5.4  智能指针的创建

```cpp
// 建议使用
std::shared_ptr<T> sp = std::make_shared<T>(obj); 

// 构造函数创建
std::shared_ptr<T> sp2(new int(obj));

// 可以先声明一个空的智能指针，然后通过 reset 函数重置
std::shared_ptr<T> sp3;
sp3.reset(obj);
```

- 不能将一个裸指针直接赋值给智能指针；

### 5.5  基本用法和常用函数

#### 5.5.1  get()

作用：返回 shared_ptr 中保存的裸指针。不建议使用。

#### 5.5.2  reset（）

作用：重置 shared_ptr

```cpp
// 1. 无参 析构智能指针 s 并将 s 置空
s.reset();

// 2. 有参 析构智能指针 s，将其置空，指向新的对象 s2
s.reset(s2);
```

#### 5.5.3  s.use_gcount

作用：返回 shared_ptr 的强引用次数

#### 5.5.4  s.unique()

如果 shared_ptr 的强引用次数为 1 则返回 true；否则返回 false

### 5.6  指定删除器

在构造智能指针的时候，可以指定删除器

```cpp
#include <memory>

void DeleteIntPtr(int* p){
    std::cout << "call DeleteIntPer" << std::endl;
    delete p;
}
int main(){
    std::shared_ptr<int> p(new int(1), DeleteIntPtr);
    p.reset();
    return 0;
}
```

### 5.7  使用规范

- 使用 shared_ptr 管理资源时，不要使用裸指针
- 构造指针的时候，不要裸指针
- 尽量使用 make_shared 方法构造
- 尽量不要使用 get 方法
- 不要用一个指针构造多个智能指针对象

```c++
// 不建议的构造方式
int *p = new int();
shared_ptr<int> sp = shared_ptr<int>(p);

// 建议的构造方式
// 1
shared_ptr<int> sp = shared_ptr<int>(new int());

// 2 
shared_ptr<int> sp = make_shared<int>();
```

- 类对象指针 this 时

```cpp
class T: public enable_shared_from_this<T>
{
public:
	shared_ptr<T> self()
	{
		return shared_from_this();
	}
}
```

### 5.8  避免在函数实参中直接创建 `shared_ptr`

**避免因函数参数求值顺序的不确定性，导致在 `shared_ptr` 接管资源前发生异常，从而引发内存泄漏。**

#### 5.8.1  错误示例

```cpp
function(shared_ptr<int>(new int), g());
```

错误原因

- **参数求值顺序未定义**：在调用 `function` 之前，C++ 标准**没有规定**其参数 `new int`、`shared_ptr<int>` 构造函数和 `g()` 的求值顺序。
- **可能的致命执行序列**：如果编译器采用的执行顺序是：
    1. `new int` （分配内存）
    2. `g()` （**可能抛出异常**）
    3. `shared_ptr<int>` 构造函数 （接管内存）  
        那么当 `g()` 抛出异常时，`shared_ptr<int>` 尚未被构造，已分配的 `int` 内存将**无法被释放**，导致内存泄漏。
  太疼了！  
  身上多了六道血肉外卷的伤口，鲜血顺着皮肤流淌而下。

#### 5.8.2  正确写法

先构造，后传递

```cpp
auto p = std::make_shared<int>();
function(p, g());

// 其实，由于 make_shared方法将内存分配和构造合并为一个原子操作，其实是可以直接传递的
function(auto p = std::make_shared<int>(), g());
```

### 5.9  避免使用同一裸指针创建多个 `shared_ptr`

存在所有权接管的时机问题，释放时会导致双重析构错误

#### 5.9.1  错误示例

```cpp
int* raw_ptr = new int;
std::shared_ptr<int> sp1(raw_ptr);
// … 如果此处代码复杂或存在条件分支，可能让人误以为ptr仍需管理
std::shared_ptr<int> sp2(raw_ptr); // 灾难：两个独立的shared_ptr
                                   // 会各自尝试删除同一块内存，导致未定义行为。
```

#### 5.9.2  正确做法

如果已经将裸指针交给了一个 `shared_ptr`，后续所有需要共享所有权的场景，都应该通过拷贝 `shared_ptr` 来实现

```cpp
auto sp1 = std::make_shared<int>();
auto sp2 = sp1;
```

已为您完善并整理这份关于 `shared_from_this` 的核心笔记，补充了问题原理、解决方案、关键细节和最佳实践。

### 5.10  使用 `shared_from_this()` 安全地返回当前对象的 shared_ptr

不要将 this 指针作为 shared_ptr 返回出来，因为 this 是裸指针，因此，这样会导致重复析构

#### 5.10.1  错误示例

```cpp
#include <iostream> 
#include <memory> 
class A{ 
public: 
	std::shared_ptr<A> GetSelf(){ 
		return std::shared_ptr<A>(this); 
	} 
	~A(){ 
		std::cout << "Destructor A" << std::endl; 
	} 
}; 
int main(){ 
	std::shared_ptr<A> sp1(new A); 
	std::shared_ptr<A> sp2 = sp1->GetSelf(); // 报错 
	// free(): double free detected in tcache 2 
	// 已中止 （核心已转储）./a.out 
	return 0; 
} 
```

> [!warning] 直接使用 `this` 指针创建 `shared_ptr` 会导致重复析构
> - 当两个独立的 `std::shared_ptr` 都认为自己 " 独占 " 式地拥有同一个 `this` 指针指向的对象时，它们会各自维护一个**独立的引用计数**。在析构时，两个指针都会尝试删除同一块内存，导致 **"double free"** 错误。
> - **根本原因**：`std::shared_ptr<T>(this)` 这种构造方式会**创建一个全新的控制块**，而不是与已存在且管理着同一对象的 `shared_ptr` 共享控制块。

> [!tip] 解决方案：继承 `std::enable_shared_from_this`
> C++ 标准库提供了 `std::enable_shared_from_this` 模板类来解决此问题。它让一个**已被 `shared_ptr` 管理的对象**能够安全地生成一个与其共享所有权的额外 `shared_ptr`。

#### 5.10.2  正确用法

```cpp
#include <memory>
#include <iostream>

class A : public std::enable_shared_from_this<A> { // 必须公有继承
public:
    std::shared_ptr<A> getSelf() {
        return shared_from_this(); // 关键：返回共享所有权的shared_ptr
    }
    void print() {
        std::cout << "A::print()" << std::endl;
    }
    ~A() {
        std::cout << "Destructor A" << std::endl;
    }
};

int main() {
    auto sp1 = std::make_shared<A>(); // 第一个shared_ptr，建立控制块
    std::shared_ptr<A> sp2 = sp1->getSelf(); // 正确！sp2与sp1共享控制块

    std::cout << "sp1 use_count: " << sp1.use_count() << std::endl; // 输出 2
    std::cout << "sp2 use_count: " << sp2.use_count() << std::endl; // 输出 2

    sp1->print();
    sp2->print(); // 两者指向同一对象
    // 程序结束，引用计数归零，对象被安全析构一次
    return 0;
}
```

> [!note] 禁止在构造函数和析构函数中调用 shared_from_this()
> 因为此时对象的所有权状态未确定或正在改变

### 5.11  避免循环引用

```cpp
#include <fstream>
#include <iostream>
#include <memory>
#include <shared_mutex>

class A;
class B;

class A{
public:
    A(){
        val = new int(1);
    }
    ~A(){
        std::cout << "A is deleted" << std::endl;
        delete val;
    }

    std::shared_ptr<B> bptr;
    int* val;
};

class B{
public:
    B(){
        val = new int(1);
    }
    ~B(){
        std::cout << "B is deleted" << std::endl;
    }
    std::shared_ptr<A> aptr;
    int* val;
};

void test(){
    auto ap = std::make_shared<A>();
    std::weak_ptr<A> wp1 = ap;
    std::weak_ptr<A> wp2 = ap;
    std::cout << "ap.use_count()" << ap.use_count() << std::endl;
}

void test2(){
    std::weak_ptr<A> wp;
    {
        auto ap = std::make_shared<A>();
        wp = ap;
    }
    std::cout << "wp.use_count() " << wp.use_count() 
    << ", wp.expired() "<< wp.expired() << std::endl;

    auto ptr = wp.lock();
    if(!wp.expired()){
        *(ptr->val) = 20;
    }
}

int main(){
    auto ap = std::make_shared<A>();
    auto bp = std::make_shared<B>();

    std::cout << "ap.use_count()" << ap.use_count() << std::endl; // 1
    std::cout << "bp.use_count()" << bp.use_count() << std::endl; // 1

    // 循环引用导致 A 和 B 都无法释放
    ap->bptr = bp;
    bp->aptr = ap;

    std::cout << "ap.use_count()" << ap.use_count() << std::endl; // 2
    std::cout << "bp.use_count()" << bp.use_count() << std::endl; // 2

    std::cout << "main leave" << std::endl; 

    // 只打印了：main leave，因为A和B并没有调用析构函数
    // 当程序结束，也就是两个智能指针脱离了作用域后，都进行了 use_count - 1
    // 因为A和B的引用次数都为 2,减少 1 后为 1，大于 0,因此不会调用析构函数

    return 0;
}
```

## 6  std::weak_ptr

- 弱引用的指针
- 只引用，不计数
- 不能够直接使用，需要辅助 shared_ptr 来使用
- 只有 make_shared 函数才会维持弱引用

### 6.1  针对问题：shared_ptr 的循环引用问题

- 如果有两个 shared_ptr 指针相互引用，则这两个指针将无法自动释放
- 解决的方法为：手动释放，或使用 weak_ptr

### 6.2  弱引用

当一个 shared_ptr 指针和一个 weak_ptr 指针引用相同一块内存时，如果 shared_ptr 释放掉了该内存，那么该内存将会被真的释放掉。此时，weak_ptr 将变成空指针。

因此，在使用 weak_ptr 前，一定要检查其是否为空指针

### 6.3  基本用法

#### 6.3.1  use_count()

作用：获取当前观察资源的引用次数

```cpp
std::shared_ptr<int> sp(new int(10));
std::weak_ptr<int> wp(sp);
std::cout << wp.use_count() << std::endl;
```

#### 6.3.2  expired()

判断所观察的资源是否已经释放

```cpp
shared_ptr<int> sp(new int(10));
weak_ptr<int> wp(sp);
if(wp.expired()){
	std::cout << "weak_ptr 无效， 资源已经释放" << std::endl;
}else{
	std::cout << "weak_ptr 有效" << std::endl;
}
```

#### 6.3.3  lock()

`lock()` 方法会**原子性地检查**其观察的对象是否仍然存活（即对应的 `shared_ptr` 引用计数是否大于 0）。

- 如果存活，则返回一个持有该对象所有权的 `shared_ptr`，从而延长对象的生命周期；
- 如果对象已被释放，则返回一个空的 `shared_ptr`。

```cpp
std::weak_ptr<int> gw;
void f(){
	//
	auto spt = gw.lock();
	if(gw.expired()){
		std::cout << "gw 无效，资源已经被释放" << std::endl;
	}else{
		std::cout << "gw 有效， *spt = " << *spt << std::endl;
	}
}

int main(){
	{
		auto sp = std::make_shared<int>(42);
		gw = sp;
		f();
	}
	f();
	return 0;
}
```

> [!question] 为什么需要 lock()
> - `weak_ptr` 本身不拥有对象的所有权，不增加引用次数。它只是一个 " 观察者 "。不能直接通过 `weak_ptr` 来访问对象。
> - 由于弱引用本身不控制对象的生命周期，因此，在想要使用对象时，对象可能已经不存在了。
> - `lock()` 提供了唯一一种线程安全且无竞态条件的方式来获取一个临时所有权 (`shared_pt`r)，从而安全访问对象或确认其已经被销毁

### 6.4  通过 weak_from_this() 返回 this 指针

`std::enable_shared_from_this` 类模板不仅提供了 `shared_from_this()` 来获取共享所有权的 `shared_ptr`，还提供了 `weak_from_this()` 来获取一个不增加引用计数的观察者 `weak_ptr`。

```cpp
class Myclass: public std::enable_shared_from_this<Myclass>{
public:
    std::weak_ptr<Myclass> getSelf(){
        return weak_from_this();
    }
    void doSomething(){
        std::cout << "Myclass::doSomething() called.\n";
    }
};

int main(){
    // 1. 对象必须由 shared_ptr 所管理
    auto sp = std::make_shared<Myclass>();

    // 2. 安全获取一个指向自身的 weak_ptr
    auto wp = sp->getSelf();

    // 3. 通过 lock() 升级为 shared_ptr
    if(auto locked = wp.lock()){
        locked->doSomething();
        std::cout << "Obj is alive. use_count(): " << locked.use_count() << std::endl;
    }else{
        std::cout << "obj has been destroyed.\n";
    }
    return 0;
}
```

### 6.5  weak_ptr 使用注意事项

1. weak_ptr 使用前需要检查合法性

```cpp
// 1. 通过 expired 函数检查
auto lsp = wp.lock();
if(wp.expired()){
	cout << "wp所观察的指针已经被释放" << endl;
}else{
	cout << "wp 可以使用" << endl;
}

// 2. 通过 lock() 直接判断
if(auto lsp = wp.lock()){
	cout << "wp可以使用." << endl;
}else{
	cout << "wp所观察的指针已经被释放" << endl;
}

```

## 7  shared_ptr 实现

```cpp
/*
基于引用次数的智能指针的实现
*/

#include <cstddef>
#include <iostream>
#include <stdexcept>
template <typename T>
class SmartPointer
{
public:
    // 构造函数
    SmartPointer(T* p = 0): _ptr(p), _reference_count(new size_t)
    {
        if(p)
            *_reference_count = 1;
        else
            *_reference_count = 0;
    }
    // 拷贝构造函数
    SmartPointer(const SmartPointer& src)
    {
        if(this!=&src)
        {
            _ptr = src._ptr;
            _reference_count = src._reference_count;
            (*_reference_count)++;
        }
    }
    // 重载赋值运算符
    SmartPointer& operator=(const SmartPointer& src)
    {
        if(_ptr == src._ptr)
        {
            return *this;
        }
        releaseCount();
        _ptr = src._ptr;
        _reference_count = src._reference_count;
        (*_reference_count)++;
        return *this;
    }
    // 重载操作符
    T& operator*()
    {
        if(!_ptr)
            throw std::runtime_error("Dereferencing null pointer");
        return *_ptr;
    }
    // 重载操作符
    T* operator->()
    {
        if(!_ptr)
            throw std::runtime_error("Dereferencing null pointer");
        return _ptr;
    }
    // 析构函数
    ~SmartPointer()
    {
        releaseCount();
    }
    bool isNull() const {
        return _ptr == nullptr;
    }

    size_t use_count(){
        return _ptr ? *_reference_count : 0;
    }
private:
    T* _ptr;    // 指针
    std::size_t* _reference_count; // 引用次数

    void releaseCount()
    {
        if(_ptr)
        {
            (*_reference_count)--;
            if((*_reference_count) == 0)
            {
                delete _ptr;
                delete _reference_count;
            }
        }
    }
};
```

## 8  智能指针里的计数器何时会改变

1. 创建一个新的智能指针对象时，引用次数被初始化为 1；
2. 通过已有对象创建新对象时，将调用拷贝构造函数，新创建对象的引用次数为原对象的引用次数加 1；
3. 进行赋值操作时 (如果是自己给自己赋值，则引用次数不改变)
	1. 左操作数的引用次数减 1
	2. 右操作数引用次数加 1
4. 对象离开作用域或被显式销毁时，将会调用析构函数
	1. 引用次数将会减 1,如果引用次数为 0,将释放指针

## 9  智能指针和管理的对象分别在哪个区

智能指针的原理是通过将指针的声明周期绑定在**栈对象**上，从而实现资源的自动释放。

因此，智能指针对象本身是处于**栈区**的。

其托管的资源，一般是通过 new 在**堆区**开辟的内存空间。因此，其托管的资源是处于堆区的。

而其指向的对象，则取决于该对象是如何创建的

- 通过 new 运算符在堆上动态分配，则其在堆区
- 如果该对象是栈对象或全局变量定义，则其所占用的内存位于栈区或静态数据区。

## 10  智能指针线程安全问题

- 智能指针本身是多线程安全的
- ref count 是安全的
- 智能指针指向的对象，不保证线程安全
- 如果要保证智能指针指向的对象的多线程安全性，就需要对该对象的修改添加锁或其他多线程同步机制
