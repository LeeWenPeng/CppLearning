## 1  值的类别

值的类别是表达式的属性

- 左值
- 右值
	- 纯右值
	- 将亡值

## 2  左值

- 确定了对象或函数的标识，也就是具名对象
- 具有地址，存储在内存中
- **可以取地址**
- 可以出现在 = 的左侧
- 变量、对象、数组元素

## 3  右值

- 没有名字的临时值
- 通常没有地址，存储在寄存器或临时内存中
- **不可以取地址**
- 位于 = 的右侧，不能出现在 = 的左侧
- 字面值（除了字符串字面值）、表达式结果

### 3.1  右值的分类

1. 纯右值：临时变量和不与变量相关联的字面值量
2. 将亡值：（ 其实是泛左值和右值的交集）
	1. 返回右值引用 T&& 的函数返回值
	2. std::move 的返回值
	3. 转换为 T&& 的类型转换函数的返回值

### 3.2  将亡值的产生

一， 将左值转换为该类型的右值引用

- `static_cast<type&&>`
- `std::move(vriable)`
	- 本质上仍然是 `static_cast` 强制转换

二， 临时量的实质化：纯右值转换到临时对象的过程。

```cpp
struct X{
	int a;
}

int main(){
	int b = X().a;
}
```

- 上述代码中，X() 为纯右值，访问其成员变量 a 需要一个泛左值。所以这里会发生一次临时量的实质化，将 X() 转换为将亡值，最后再访问其成员变量 a。

> [!tip] 将亡值概念确定的原因
> 是为了编译器强制进行复制构造消除，也就是 RVO 优化

### 3.3  几个特殊情况

```c++
x++; // 是右值
// 系统首先复制出一个临时值
// 然后， x = x+1
// 然后，将临时值返回

++x; // 是左值
// 系统直接在 x 上进行加一

printf("%d\n", &("string")); // 字符串字面值是左值
```

## 4  引用基本语法

```cpp
数据类型& 引用名 = 变量;
```

> - 引用的数据类型必须要原变量的数据类型保持一致
> - 引用创建的别名和原变量名，二者代表的是同一块内存，只是称呼改变了而已，" 起别名 " 嘛

## 5  引用的概念

- 通常，引用指**非常量左值引用**
- 引用必须被初始化
- 引用一旦初始化，就不可以更改了
- **非常量左值引用必须初始化左值**

## 6  引用做函数参数 (引用传递)

参数传递的三种方法：

1. 值传递 - 形参不会修饰实参
2. 地址传递 - 形参会修饰实参
3. 引用传递 - 形参会修饰实参

   示例代码：

   ```c++
   #include <iostream>
   using namespace std;
   
   void swap01(int &a, int &b) {
   	int temp = a;
   	a = b;
   	b = temp;
   }
   
   int main() {
   
   	int a = 10;
   	int b = 20;
   
   	swap01(a,b);
   
   	cout << a << endl;
   	cout << b << endl;
       
   	system("pause");
   	return 0;
   }
   ```

> [!note] 引用传递，可以修改实参的原因
>
 > - `swap01()` 函数中的两个形参为 `int &a`、`int &b`，而传入是实参为 `a` 和 `b`
>   - 也就是说，在参数传递时，形参 `a` 和 `b` 就变成了实参 `a` 和 `b` 的两个别名 (和原名一样的别名，hh)
 >  - 也就是说，形参 `a` 和 `b` 对应的内存空间就是实参 `a` 和 `b` 对应的内存空间所以对形参 `a` 和 `b` 的操作，其实就是在对实参 `a` 和 `b` 的操作

## 7  引用做函数返回值

> [!note] 不能传递局部变量的引用，为什么？
> 局部变量在函数执行结束后，会被编译器自动释放。因此，最后传递的将是随机地址。

- **当引用做函数返回值的时候，可以做等式的左值被赋值**
  - 类似于三元操作符，返回的是一个变量，是可以被赋值的
  - ==链式操作==就是基于此

## 8  引用的本质

### 8.1  引用是变量别名

变量的本质是内存地址的别名。例如，

```cpp
int a = 10;
```

变量 a 所代表的其实是系统中的一块内存，而这块内存中存放着整型 10。

而引用则是变量的别名，比如

```cpp
int &b = a;
```

变量 b 是变量 a 的引用。这时，变量 b 所代表的内存和变量 a 所代表的内存为同一块内存。换句话说，变量 b 和变量 a 是同一块内存地址的两个名称。比如，

```cpp
printf("%d\n", &b == &a); // 1
```

### 8.2  在概念上，引用相当于常量指针

> [!note] 危险的指针
通过指针，可以获取左值地址。但由于指针可以修改其指向的内存，因此存在内存泄漏的风险

- 引用诞生的目的是为了解决指针存在内存泄漏的风险。
- 引用在初始化后，不可以改变其指向。因此，其在概念上相当于一个指针常量。

```cpp
int a = 10;

int& b = a; // 引用

int* const d = a; // 指针常量
```

共同点

- 必须在定义的时候初始化
- 指向的内存不允许修改

> [!note] 复习
  > - 常量指针：指针是一个常量，指针指向的值可以改，但指向不可以改
  > - 指向常量的指针：指向一个常量的指针，值不可以改，指向可以改

代码：

```c++
#include <iostream>
using namespace std;

int main(){
    
    //创建一个变量
    int a = 10;
    
    //声明一个引用
    int& ref = a;//编译器会自动将这个语法转换为   int const* ref = &a;
    ref = 20;//编译器发现ref是引用后，会自动将这个语法转换为   *ref = 20;
    
    cout << "ref = " << ref << endl;
    cout << "a = " << a << endl;
     
    system("pause");
    return 0;
}
```

## 9  常量左值引用

- 也叫常量引用
- 可以引用左值，也可以引用右值

作用：修饰形参，防止误操作。地址传递中使用 `const` 修饰形参防止误操作

使用场景：函数功能中不含有参数修改操作时，应该传入常量引用。

代码：

```c++
#include <iostream>
using namespace std;

int printVal(int& val){
    cout << "val = " << val <<endl;
}

int main(){
    
    int a = 10;
    //int& ref = 10;//引用必须指向一个合法内存
    const int& ref = 10;//允许，编译器会将语句自动转化为 
    //int temp = 10;const int& ref = temp;
    
    //const 修饰形参
    
    
    system("pause");
    return 0;
}
```

### 9.1  常量左值引用和拷贝构造、复制赋值运算符函数的形参

```cpp
class X{
public:
	X(){}
	// X(X&){}
	X(const X&){} // 拷贝构造器
	X& operator= (const X&){return *this;}
}
X make_X(){
	return X();
}

int main(){
	X x1;
	X x2(x1);
	X x3(make_X());
	X x4 = make_X();
}
```

- 构造函数和复制赋值运算符函数的形参应该是常量左值引用
- 如果是左值引用，而非常量左值引用，那么会报错
	- x3、x4 的构造会报错
	- 因为 make_X() 函数的返回值，是右值
	- 而在 x3 构造时，使用的是拷贝构造
	- x4 构造时，使用的是复制赋值运算符函数
	- 二者形参都需要非常量左值引用，却传递了右值
	- 因此会报错

> [!question] 为何在实际实践过程中，构造函数和复制赋值运算符函数的形参是非常量左值引用，却没有报错？
> - 是因为编译器的函数返回值优化 (RVO)
> - GCC 的 RVO 优化会减少复制构造函数的调用

> [!tip] 关闭编译器 RVO 优化
> GCC 编译时，添加命令行参数 `-fno-elide-constructors`

### 9.2  常量左值引用右值的缺点

- 常量性：一旦使用了常量左值引用，便无法修改该对象的内容（强制类型转换除外）

## 10  右值引用

- 一般右值引用只能引用右值，而不能引用左值
	- 特殊情况：通过 `std::move()` 可以将左值转化为右值，从而可以引用

```cpp
// 左值引用
type& 引用名 = 左值;

// 右值引用
type&& 引用名 = 右值;

const type&& 引用名 = 右值;
```

### 10.1  右值引用优化拷贝构造和复制赋值操作符函数

- 延长右值的生命周期

```cpp
class X{
public:
	X(){}
	// X(X&){}
	X(const X&){}
	X& operator= (const X&){return *this;}
}
X make_X(){
	return X();
}

int main(){
	X x1;
	X x2(x1);
	X x3(make_X());
	X x4 = make_X();
	X&& x5 = make_X(); // 优化
}
```

- `X x4 = make_X();` 的构造过程 (不考虑编译器优化)
	- 第一次构造：`x1 = X()`，调用一次默认构造
	- 第二次构造：`return x1`，会使用复制构造产生一个临时对象 x2，x1 析构
	- 第三次构造：`x4 = x2`，会使用复制构造，将临时对象 x2 复制给 x4， x2 析构
- `X&& x5 = make_X();` 右值引用的构造过程
	- 第一次构造：`x1 = X()`，调用一次默认构造
	- 第二次构造：`return x1`，会使用复制构造产生一个临时对象 x2，x1 析构
	- 右值引用 `X&& x5 = x2;`，将临时对象 x2 的声明周期延长

### 10.2  常量右值引用

无实际用处

```cpp
const T&& 引用名 = 右值;
```

- 其完全可以被常量左值引用代替

### 10.3  右值引用和移动语义

- 移动语义：
	- 移动的是右值代表的资源。
	- 右值是一定可以移动的。
	- 目的是应对拷贝带来的开销。
- 移动语义的步骤
	1. 将源对象的指针拿走
	2. 将源对象的指针置空
- 拷贝的步骤
	1. 开辟一块新的内存空间
	2. 将源对象内存空间内的数据复制到新的内存空间之中

```cpp
class X{
public:
	X(){}
	X(X&&) noexcept {} // 移动构造器，需要使用 noexcept 说明符
	X(const X&){} // 复制构造器
	X& operator= (const X&){return *this;}
}
X make_X(){
	return X();
}

int main(){
	X x1;
	X x2(x1);
	X x3(make_X());
	X x4 = make_X();
	X&& x5 = make_X(); // 优化
}
```

- 移动语义的风险：在资源移动到另一个对象时发生了异常。也就是说，一部分发生了转移，而另一部分没有。
- 因此，需要使用 noexcept 说明限制该函数。一旦该函数抛出异常，程序不再继续执行，而是调用 `std::terminate` 中止执行。

#### 10.3.1  noexcept

#### 10.3.2  throw

C++ 11 以前，使用 throw(optional_type_list) 声明函数是否抛出异常，并描述函数抛出异常的类型。

- 运行时，检查函数发出任何异常是否存在于 optional_type_list 中，或者为该列表中某个类型派生
- 如果不是，则会调用异常处理程序 std::unexpected。

#### 10.3.3  移动构造的异常陷阱

- 如果原始容器中的数据在移动新容器的过程中发生异常。也就是说，一部分数据发生了转移，而另一部分没有。那么，此时无论是新容器还是原始

#### 10.3.4  noexcept 优化移动语义

```cpp
#include <iostream>
#include <type_traits
struct X {
	X() {}
	X(X&&) noexcept {}
	X(const X&) {}
	X operator= (X&&) noexcept { return *this; }
	X operator= (const X&) { return *this; }
};
struct X1 {
	X1() {}
	X1(X1&&) {}
	X1(const X1&) {}
	X1 operator= (X1&&) { return *this; }
	X1 operator= (const X1&) { return *this; }
};

template<typename T>
void swap_impl(T& a, T& b, std::integral_constant<bool, true>) noexcept{
	T tmp(std::move(a));
	a = std::move(b);
	b = std::move(tmp);
}
template<typename T>
void swap_impl(T& a, T& b, std::integral_constant<bool, false>){
	T tmp(a);
	a = b;
	b = tmp;
}
template<typename T>
void swap(T& a, T& b)
noexcept(noexcept(swap_impl(a, b, std::integral_constant<bool, noexcept(T(std::move(a)))
&& noexcept(a.operator=(std::move(b)))>()))){
	swap_impl(a, b, std::integral_constant<bool, noexcept(T(std::move(a)))
	&& noexcept(a.operator=(std::move(b)))>());
}

int main(){
	X x1, x2;
	swap(x1, x2);
	X1 x3, x4;
}

```

- 实现了两个版本的 swap_impl 函数
	- noexcept(T(std\:\:move(a))) && noexcept(a.operator=(std\:\:move(b))) 为真，则实例化移动拷贝和移动赋值操作符函数
	- 否则，则实例化拷贝构造和复制赋值操作符函数

### 10.4  右值引用和左值

- 一般右值引用只能引用右值，而不能引用左值
- 除非通过 `std::move()` 函数将左值转化为右值

左值转换为右值的两种方法

```cpp
int  a = 10;

// 1 通过 static_cast<type&&> 强制类型转化
int&& b = static_cast<int&&>(a);

// 2 通过 std::move 函数
int&& v = std::move(a);
```

### 10.5  std::move()

作用：将左值转变为右值

语法

```cpp
T v2;
T&& v1 = std::move(v2);
```

- 上述代码中，v2 为 T 类型的对象，为一个左值。
- 在对 v1 进行构造时，使用了移动构造函数，将 v2 转换成了右值
- 由于调用了移动构造函数，v2 失去了自己的内存数据，后面代码不能对 v2 进行操作
- 后续使用 v2 会发生未定义的行为。

#### 10.5.1  std::move 的本质是指针的移动

```cpp
int v1 = 5;
int& v2 = v1;
int&& v3 = std::move(v1);

cout << &v1 << endl; 
cout << &v2 << endl; 
cout << &v3 << endl;
// 上述三个打印结果相同，都是 v1 的地址

v2 = 6;
v3 = 7;

cout << v1 << endl;
cout << v2 << endl;
cout << v3 << endl;
// 上述三个打印结果相同，都是 7，因为 v1、v2、v3 都是相同的地址
```

- `std::move()` 函数的本质不会真正的 " 移动 " 数据，只是改变了对象的属性
	- `std::move()` 将对象改变成右值，也被称为将亡值
	- 但对象的生命周期和内存地址都没有进行改变
- 其最大作用为：让左值使用移动语义。也就是，在传递参数和赋值时，触发移动构造和移动赋值，避免深拷贝，提高性能
- 在实现上，其等价于 `static_cast<T&&>(v);`
- 在应用场景上，`std::move` 适用于在内部堆上开辟了大内存的情况，而基础类型的传参代价较小，则不需要使用

### 10.6  右值引用和左值引用的本身是一个左值

```cpp
void move_pool(BigMemoryPool &&pool){
	std::out << "call move_pool" << std::endl;
	BigMemoryPool my_pool(pool);
}

int main(){
	move_pool(make_pool());
}
```

结果和分析

```cpp
// 复制构造 make_pool() 返回一个临时对象，这里有一次复制构造
copy big memory pool. 
// make_pool() 返回的值为右值，move_pool() 的形参为右值引用，这里有一个移动构造
move big memory pool. 
call move_pool
// 复制构造 尽管 pool 是右值引用，但其本身为一个左值，因此 my_pool(pool) 为一个复制构造
copy big memory pool. 
```

为了使得 my_pool() 进行移动构造，需要对 pool 进行强转

```cpp
void move_pool(BigMemoryPool &&pool){
	std::out << "call move_pool" << std::endl;
	BigMemoryPool my_pool(std::move(pool));
}
```
