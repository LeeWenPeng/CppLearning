## 1  基本概念：作用域和 RAII

在 C++ 中，大括号 `{}` 创建一个**局部作用域**。任何在作用域内创建的对象，在离开作用域时会自动调用析构函数。

`std::lock_guard` 就是利用这个特性实现 **RAII（资源获取即初始化）**：

- **构造时**自动加锁
- **析构时**自动解锁

### 1.1  示例

```cpp
void producer() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    
    {  // 开始作用域
        std::lock_guard<std::mutex> lock(mtx);
        shared_data = 42;
        data_ready = true;
        std::cout << "Producer: data is ready" << std::endl;
    }  // 结束作用域，lock 析构，自动解锁
    
    cv.notify_one();  // 在锁外通知，提高性能
}
```

## 2  什么时候应该使用这种技巧？

### 2.1  应该使用的情况

1. **需要精确控制资源生命周期时**
2. **希望减少锁的持有时间**
3. **有昂贵的资源需要尽早释放**
4. **代码逻辑有明显的阶段划分**

### 2.2  不需要使用的情况

1. **整个函数都是临界区**
2. **资源持有时间本来就很短**
3. **代码逻辑简单，不需要分段**
