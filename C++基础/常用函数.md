## 1  assert 函数

### 1.1  定义和作用

`assert` 是一个**调试辅助宏**，用于在程序运行时检查假设条件是否成立。如果条件不成立，程序会立即终止并输出错误信息。

### 1.2  函数原型

```c
#include <assert.h>
void assert(int expression);
```

### 1.3  基本用法

```c
#include <stdio.h>
#include <assert.h>

int main() {
    int x = 10;
    int y = 5;
    
    // 检查条件是否成立
    assert(x > y);        // 条件成立，程序继续执行
    assert(x == 10);      // 条件成立，程序继续执行
    assert(y != 0);       // 条件成立，程序继续执行
    
    int result = x / y;   // 安全的除法操作
    printf("Result: %d\n", result);
    
    return 0;
}
```

### 1.4  断言失败的情况

```c
#include <assert.h>
#include <stdio.h>

void process_array(int *arr, int size) {
    // 检查指针不为NULL
    assert(arr != NULL);
    
    // 检查数组大小合理
    assert(size > 0);
    
    for(int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

int main() {
    int arr[] = {1, 2, 3};
    
    process_array(arr, 3);  // 正常执行
    process_array(NULL, 3); // 断言失败：arr != NULL
    process_array(arr, 0);  // 断言失败：size > 0
    
    return 0;
}
```

### 1.5  断言失败时的输出

当断言失败时，程序会输出类似这样的信息：

```cpp
Assertion failed: arr != NULL, file example.c, line 8
```

然后调用 `abort()` 终止程序。

### 1.6  禁用断言

在发布版本中，可以通过定义 `NDEBUG` 宏来禁用所有断言：

```c
#define NDEBUG  // 必须在包含 assert.h 之前定义
#include <assert.h>

int main() {
    int *ptr = NULL;
    assert(ptr != NULL);  // 这行代码会被编译器忽略
    
    printf("程序继续执行\n");
    return 0;
}
```

### 1.7  实际应用场景

#### 1.7.1  参数验证

```c
int divide(int a, int b) {
    assert(b != 0);  // 确保除数不为零
    return a / b;
}
```

#### 1.7.2  数据结构完整性检查

```c
struct list_node {
    int data;
    struct list_node *next;
};

void insert_node(struct list_node **head, int data) {
    assert(head != NULL);  // 头指针指针不能为NULL
    
    struct list_node *new_node = malloc(sizeof(struct list_node));
    assert(new_node != NULL);  // 内存分配必须成功
    
    new_node->data = data;
    new_node->next = *head;
    *head = new_node;
}
```

#### 1.7.3  算法前提条件检查

```c
int binary_search(int arr[], int size, int target) {
    assert(arr != NULL);
    assert(size >= 0);
    
    // 检查数组是否已排序（简化版）
    for(int i = 1; i < size; i++) {
        assert(arr[i] >= arr[i-1]);  // 二分查找要求数组有序
    }
    
    // 二分查找实现…
}
```

### 1.8  assert 与错误处理的区别

| 特性 | assert | 错误处理 (if 语句) |
|------|--------|------------------|
| **目的** | 调试阶段捕获编程错误 | 处理运行时可能出现的错误 |
| **发布版本** | 通常被禁用 | 始终生效 |
| **性能影响** | 发布版本无影响 | 始终有性能开销 |
| **适用场景** | 不应该发生的错误 | 可能发生的错误 |

```c
// 使用assert（用于调试）
assert(pointer != NULL);  // 这绝对不应该发生

// 使用错误处理（用于生产环境）
if (pointer == NULL) {
    fprintf(stderr, "内存分配失败\n");
    return ERROR_CODE;
}
```

### 1.9  最佳实践

#### 1.9.1  不要在有副作用的表达式中使用 assert

```c
// 错误用法
assert(++x > 0);  // 发布版本中x不会自增

// 正确用法
x++;
assert(x > 0);
```

#### 1.9.2  提供有意义的错误信息（自定义 assert）

```c
// 自定义带信息的assert宏
#define ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            fprintf(stderr, "Assertion failed: %s, file %s, line %d\n", \
                   message, __FILE__, __LINE__); \
            abort(); \
        } \
    } while(0)

// 使用示例
ASSERT(ptr != NULL, "指针不能为NULL");
```

#### 1.9.3  合理选择使用场景

```c
void critical_operation(int *data) {
    // 适合用assert的情况（程序逻辑错误）
    assert(data != NULL);           // 调用者必须提供有效指针
    
    // 适合用错误处理的情况（运行时错误）
    FILE *file = fopen("data.txt", "r");
    if (file == NULL) {
        perror("无法打开文件");      // 文件可能确实不存在
        return;
    }
    
    // 继续处理…
}
```

### 1.10  总结

`assert` 是一个重要的调试工具，主要用于：

- **开发阶段**：快速发现和定位程序逻辑错误
- **前提条件检查**：验证函数调用时的假设条件
- **不变式维护**：确保程序执行过程中的关键条件始终成立

记住：**assert 用于捕获 " 不应该发生 " 的错误，而错误处理用于处理 " 可能发生 " 的错误。**
