## 1  动态多态与静态多态（CRTP）对比分析

### 1.1  动态多态（虚函数实现）

#### 1.1.1  完整实现代码

```cpp
#include <iostream>
#include <vector>
#include <memory>

namespace dynamic_polymorphism 
{
    // 抽象基类
    struct game_unit 
    {
        virtual ~game_unit() = default;
        virtual void attack() = 0;
        
        // 可以添加其他虚函数
        virtual void move() {
            std::cout << "unit is moving\n";
        }
    };
    
    struct knight : game_unit 
    {
        void attack() override {
            std::cout << "knight draws sword\n";
        }
        
        void move() override {
            std::cout << "knight rides horse\n";
        }
    };

    struct mage : game_unit 
    {
        void attack() override {
            std::cout << "mage spells magic curse\n";
        }
        
        void move() override {
            std::cout << "mage teleports\n";
        }
    };

    struct archer : game_unit 
    {
        void attack() override {
            std::cout << "archer shoots arrow\n";
        }
    };

    // 多态函数 - 可以处理任何 game_unit 派生类
    void fight(std::vector<game_unit*> const &units) {
        for(auto unit : units) {
            unit->attack(); // 运行时多态
        }
    }
    
    void move_units(std::vector<game_unit*> const &units) {
        for(auto unit : units) {
            unit->move(); // 运行时多态
        }
    }
}
```

#### 1.1.2  使用示例

```cpp
void demo_dynamic_polymorphism() {
    using namespace dynamic_polymorphism;
    
    std::vector<game_unit*> units;
    
    // 创建不同类型的对象
    units.push_back(new knight());
    units.push_back(new mage());
    units.push_back(new archer());
    
    std::cout << "=== Dynamic Polymorphism Demo ===\n";
    fight(units);      // 多态调用
    move_units(units); // 多态调用
    
    // 清理内存
    for(auto unit : units) {
        delete unit;
    }
}
```

#### 1.1.3  动态多态优缺点分析

##### 优点

- **高度灵活**：运行时决定调用哪个函数
- **异构容器**：可以将不同类型对象存入同一容器
- **易扩展性**：添加新类型无需修改现有代码
- **接口清晰**：明确的抽象基类定义接口

##### 缺点

- **性能开销**：
  - 虚函数调用需要查虚表（vtable）
  - 每次调用多一次间接寻址
  - 无法内联优化
- **内存开销**：
  - 每个对象需要存储虚表指针（通常 8 字节）
- **运行时绑定**：无法在编译期优化

### 1.2  虚表的大小

为指针大小，4 个字节

### 1.3  静态多态（CRTP 实现）

#### 1.3.1  完整实现代码

```cpp
#include <iostream>
#include <vector>

namespace static_polymorphism 
{
    // CRTP 基类模板
    template <typename T>
    class game_unit 
    {
    public:
        void attack() {
            // 编译时多态：静态转换调用具体类型的实现
            static_cast<T*>(this)->do_attack();
        }
        
        void move() {
            // 提供默认实现，派生类可以覆盖
            static_cast<T*>(this)->do_move();
        }
        
    protected:
        // 默认实现
        void do_move() {
            std::cout << "unit is moving\n";
        }
    };

    class knight : public game_unit<knight> 
    {
    public:
        void do_attack() {
            std::cout << "knight draws sword\n";
        }
        
        void do_move() {
            std::cout << "knight rides horse\n";
        }
    };

    class mage : public game_unit<mage> 
    {
    public:
        void do_attack() {
            std::cout << "mage spells magic curse\n";
        }
        
        void do_move() {
            std::cout << "mage teleports\n";
        }
    };

    class archer : public game_unit<archer> 
    {
    public:
        void do_attack() {
            std::cout << "archer shoots arrow\n";
        }
        // 使用基类的 do_move() 默认实现
    };
    
    // 模板函数 - 编译时多态
    template <typename T>
    void fight(std::vector<T>& units) {
        for(auto& unit : units) {
            unit.attack(); // 编译时确定调用
        }
    }
    
    // 或者使用通用模板处理不同类型的容器
    template <typename Container>
    void move_units(Container& units) {
        for(auto& unit : units) {
            unit.move(); // 编译时确定调用
        }
    }
}
```

#### 1.3.2  使用示例

```cpp
void demo_static_polymorphism() {
    using namespace static_polymorphism;
    
    std::cout << "\n=== Static Polymorphism Demo ===\n";
    
    // 每种类型需要自己的容器
    std::vector<knight> knights = {knight(), knight()};
    std::vector<mage> mages = {mage(), mage()};
    std::vector<archer> archers = {archer(), archer()};
    
    std::cout << "Knights fighting:\n";
    fight(knights);  // 编译时实例化 fight<knight>
    
    std::cout << "Mages fighting:\n";
    fight(mages);    // 编译时实例化 fight<mage>
    
    std::cout << "Moving units:\n";
    move_units(knights);
    move_units(mages);
    move_units(archers);
}
```

#### 1.3.3  静态多态优缺点分析

##### 优点

- **高性能**：
  - 无虚函数调用开销
  - 函数可以被内联优化
  - 编译期确定函数调用
- **无内存开销**：不需要虚表指针
- **编译期检查**：类型错误在编译时发现

##### 缺点

- **缺乏灵活性**：
  - 无法创建异构容器
  - 运行时无法改变行为
- **代码膨胀**：模板实例化可能生成更多代码
- **接口隐式**：没有明确的接口基类

### 1.4  性能对比测试

```cpp
#include <chrono>

void performance_comparison() {
    using namespace std::chrono;
    
    const int ITERATIONS = 1000000;
    
    // 动态多态性能测试
    {
        dynamic_polymorphism::knight k;
        dynamic_polymorphism::game_unit* unit = &k;
        
        auto start = high_resolution_clock::now();
        for(int i = 0; i < ITERATIONS; ++i) {
            unit->attack();
        }
        auto end = high_resolution_clock::now();
        auto duration = duration_cast<microseconds>(end - start);
        std::cout << "Dynamic polymorphism: " << duration.count() << " microseconds\n";
    }
    
    // 静态多态性能测试
    {
        static_polymorphism::knight k;
        
        auto start = high_resolution_clock::now();
        for(int i = 0; i < ITERATIONS; ++i) {
            k.attack();
        }
        auto end = high_resolution_clock::now();
        auto duration = duration_cast<microseconds>(end - start);
        std::cout << "Static polymorphism: " << duration.count() << " microseconds\n";
    }
}
```

### 1.5  混合方案：结合两者优势

```cpp
namespace hybrid_approach 
{
    // 使用 CRTP 提供高效实现，同时保留虚函数接口
    template <typename T>
    class game_unit_impl {
    public:
        void attack_impl() {
            static_cast<T*>(this)->do_attack();
        }
        
        void move_impl() {
            static_cast<T*>(this)->do_move();
        }
    };

    // 动态多态接口
    class game_unit {
    public:
        virtual ~game_unit() = default;
        virtual void attack() = 0;
        virtual void move() = 0;
    };

    // 具体类：同时继承接口和 CRTP 实现
    class knight : public game_unit, public game_unit_impl<knight> {
    public:
        void attack() override {
            attack_impl();  // 使用高效的静态多态实现
        }
        
        void move() override {
            move_impl();    // 使用高效的静态多态实现
        }
        
        void do_attack() {
            std::cout << "knight draws sword\n";
        }
        
        void do_move() {
            std::cout << "knight rides horse\n";
        }
    };
}
```

### 1.6  应用场景建议

#### 1.6.1  使用动态多态的场景

- 需要运行时类型识别和动态行为
- 需要异构对象集合
- 系统需要插件架构或运行时扩展
- 性能不是最关键因素

#### 1.6.2  使用静态多态的场景

- 性能关键的代码路径
- 类型在编译时已知
- 需要内联优化的场景
- 避免虚函数开销很重要

#### 1.6.3  实际项目中的选择

```cpp
// 游戏引擎中的典型用法：
// - 核心渲染循环：使用静态多态（性能关键）
// - 游戏对象管理：使用动态多态（需要灵活性）
// - 物理引擎：使用静态多态（性能关键）
// - UI 系统：使用动态多态（需要灵活性）
```

### 1.7  总结对比表

| 特性 | 动态多态 | 静态多态 (CRTP) |
|------|----------|-----------------|
| **实现机制** | 虚函数 + 虚表 | 模板 + 静态转换 |
| **绑定时间** | 运行时 | 编译时 |
| **性能** | 有开销（虚表查找） | 无开销（可能内联） |
| **内存占用** | 每个对象有虚表指针 | 无额外开销 |
| **灵活性** | 高（运行时多态） | 低（编译时确定） |
| **异构容器** | 支持 | 不支持 |
| **代码膨胀** | 无 | 可能有（模板实例化） |
| **编译期检查** | 有限 | 完全 |
| **适用场景** | 需要运行时灵活性 | 性能关键路径 |

两种多态方式各有优劣，在实际项目中应根据具体需求选择合适的方法，有时甚至可以结合使用以获得两者的优势。

## 2  CRTP 的注意点

1. 是通过继承以自身为模板参数的基类实现静态多态，需要注意的是以**自身为模板参数**
2. 注意不要在基类的构造和析构函数中进行指针的转换，因为，在构造时，子类对象还未构造，在析构时，子类对象可能已经被释放
