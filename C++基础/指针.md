## 1  指针的定义和使用

### 1.1  作用

通过指针间接访问内存空间

> - 内存编号是从 0 开始的，一般使用十六进制显示
> - 指针中存放的是其指向变量的内存地址

### 1.2  函数原型

```c++
变量类型* 指针名;
指针名 = &变量名;
```

### 1.3  使用方法

使用解引用的方法，可以通过指针访问其存储的内存空间中存放的数据

```c++
*指针名;
```

### 1.4  案例代码

```c++
#include <iostream>
using namespace std;

int main() {

	//指针-指针的定义与使用

	int a = 10;

	//声明一个指针
	int* p;
	//在指针中保存a的地址
	p = &a;

	cout << "a的地址为" << &a << endl;
	cout << "p = " << p << endl;

	//使用一个指针
	//可以使用解引用的方式，得到指针指向的内存空间中保存的数据
	//在指针变量前加 * 是解引用
	*p = 1000;
	cout << "a = " << a << endl;
	cout << "*p = " << *p << endl;


	system("pause");
	return 0;
}
```

## 2  指针所占内存空间

- 在**==32 位==**操作系统下，指针占**==4 个字节==**内存空间
- 在**==64 位==**操作系统下，指针占**==8 个字节==**内存空间

## 3  空指针

### 3.1  概念

指向编号为 0 的内存空间

### 3.2  作用

给指针初始化

### 3.3  注意

**空指针指向的内存是不可以访问的**

> 0~255 编号的内存空间被系统占用，不允许用户访问

代码：

```c++
#include <iostream>
using namespace std;

int main() {

	// 指针 - 空指针

	//使用空指针给指针初始化
	int* p = NULL;
	
	//空指针指向的内存不可以被访问
	//*p = 1000;//报写入权限冲突错误

	system("pause");
	return 0;
}
```

## 4  野指针

### 4.1  概念

指向非法内存空间的指针

或者说，指针的指向是未知的 (随机的、不正确的、没有明确限制的)

### 4.2  产生原因

释放内存后不及时置空，依旧指向了该内存，可能出现非法访问的错误

### 4.3  严防野指针的技巧

> 严防野指针的技巧：
>
> 1. 定义指针时将指针初始化为 NULL
> 2. 给指针分配空间后判空
> 3. 释放指针后立即将指针置空
> 4. 使用智能指针
> 
> ```c++
> int* a = NULL; //定义指针时将指针初始化为NULL
> a = (int*)malloc(sizeof(int)*n);
> assert(a != NULL);// 分配内存空间后判空
> free(a);
> a = NULL; // 释放后立即置空
> ```

## 5  const 修饰指针

**三种情况：**

1. const 修饰指针——常量指针

   **语法：**`const int * 指针名 = 变量名;`

   **特点：**

   - 指针指向可以改
   - 指针指向的值不可以改

2. const 修饰常量——指针常量

   **语法：**`int * const 指针名 = 变量名;`

   **特点：**

   - 指针指向不可以改
   - 指针指向的值可以改

3. const 修饰指针和常量

   **语法：**`const int * const 指针名 = 变量名;`

   **特点：**

   - 指针的指向不可以改
   - 指针指向的值也不可以改

**示例代码：**

```c++
#include <iostream>
using namespace std;

int main() {

	// 指针 - const修饰指针
	int a = 20;
	int b = 30;
	//1.const修饰指针 —— 常量指针
	const int* p = &a;
    int const* p = &a; // 与上一句等价
	
	p = &b; // 常量指针指向可以改
	//*p = 10;//常量指针指向的值不可以改

	//2.const修饰常量 —— 指针常量
	int* const p1 = &a;
	//p1 = &b;//指针常量的指向不可以改
	*p1 = 10;//指针常量指向的值可以改

	//3.const修饰指针和常量
	const int* const p2 = &a;
	//p2 = &b;//指向不可以改
	//*p2 = 10;//指向的值也不可以改

	system("pause");
	return 0;
}
```

> 技巧：看 const 修饰的对象是什么
>
> 比如 `const int* p` 和 `int const* p`，const 修饰的是 `int *` 或者说是 `*`，也就意味着，这里的**指针是个常量**，所以指针的值——指针中存的地址是不可以改的，也就是指针的指向不可以改，但指针内地址中存储的值是可以改的，也就是指向的值可以改；
>
> 而 `int* const p`，const 修饰的是 p，也就是 p 是常量，相当于**指针指向了一个常量**，也就是说，指针的指向是可以改的，而指针指向的值是不可以改的；
>
> `const int* const p` 就不用说了，指针的指向和指向的值都是不可以改的。

## 6  指针和数组

### 6.1  作用

利用指针访问数组元素

### 6.2  **代码**

```c++
#include <iostream>
using namespace std;

int main() {

	// 指针 - 指针和数组
	
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };

	int* p = arr;//数组名就是数组的首地址

	cout << "使用数组下标索引第一个元素为：" << arr[0] << endl;
	cout << "使用指针索引第一个元素为：" << *p << endl;

	p++;//指针向后偏移4个字节（由于指针声明时，变量类型为int，所以自增偏移4个字节）

	cout << "使用指针偏移的方式，索引第二个元素为：" << *p << endl;

	cout << "使用指针索引的方式，遍历数组: " ;
	int* p2 = arr;
	for (int i = 0; i < 10; i++) {
		cout << *p2++ << " ";
	}
	cout << endl;

	system("pause");
	return 0;
}
```

注意：

> 自增运算符 `++`、`--` 的优先级高于一元运算符 `*`，所以 `*p++`，等价于 `*(p++)`，是对指针的偏移操作，而 `(*p)++`，则是对 `p` 指针指向的内存空间中保存的数据进行自增操作

**概念**：

- 数组：多个相同类型数据的集合，存储在一段连续的内存空间里，数组名就是内存的首地址
- 指针：是一个特殊的变量，变量的值为另一个相同类型的变量的内存地址。指针名指向了指向的变量的内存的首地址

**区别**：

1. **赋值方式不同**。相同类型的指针可以互相复制，而数组只能通过一个元素一个元素复制。
2. **存储方式不同**：
   - 数组中的元素在内存中是连续的，其开辟一段连续的内存空间。而且一般数组都开辟在栈区，或者全局数组开辟在静态存储区。
   - 指针却是灵活的。指针是一个变量，

## 7  指针和函数 - 地址传递

### 7.1  介绍

- 函数的参数可以是指针的
- 通过指针进行的参数传递，叫做地址传递
- **==在地址传递中，改变形参的值，实参也会被改变==**

### 7.2  **详解**

- 场景：
	- 函数 A 中调用函数 B
	- 函数 A 中实参为 `A1`、`A2`，`函数B(&A1, &A2);`
	- 函数 B 中形参为 `B1`、`B2`，`函数B(*B1, *B2);`
- 在函数 B 被调用时，将函数 A 中实参 `A1` 和 `A2` 的地址传递给函数 B 中的形参 `B1` 和 `B2`
- 也就是说，形参 `B1` 和 `B2`，是 `A1` 和 `A2` 的指针，二者内存空间中存放的是 `A1`、`A2` 的地址
- 当形参 `B1`、`B2` 解引用后，指向的内存空间就是 `A1`、`A2` 分配的内存空间
- 当通过 `*B1` 和 `*B2` 对内存空间中存放的值进行改变时，其实就是在改变 `A1` 和 `A2` 的值
- 所以，在地址传递中，改变形参的值，实参也会被改变

代码：

```c++
#include <iostream>
using namespace std;

void swap_point(int* a, int* b);

int main() {

	// 指针 - 指针和函数 - 地址传递

	int a = 10;
	int b = 20;

	swap_point(&a, &b);

	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	system("pause");
	return 0;
}
void swap_point(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
```

## 8  指针配合数组和函数案例 - 冒泡排序

题目：封装一个函数，利用冒泡排序，实现对整型数组的升序排序

例如：数组 - `int arr[10] = {4,3,6,9,1,2,10,8,7,5};`

代码：

```c++
#include <iostream>
using namespace std;

void print_arr(int* a,int length);
void swap(int* a, int* b);
void sort_by_point(int* a,int length);
int main() {

	// 指针 - 指针配合数组和函数案例 - 冒泡排序
	//题目：封装一个函数，利用冒泡排序，实现对整型数组的升序排序封装一个函数

	//创建数组，并获得数组长度
	int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
	int length = sizeof(arr) / sizeof(arr[0]);
    
    //打印排序前的数组
	print_arr(arr, length);
    
    //排序
	sort_by_point(arr, length);
    
    //打印排序后的数组
	print_arr(arr, length);

	system("pause");
	return 0;
}

//打印数组
void print_arr(int* a, int length) {
	for (int i = 0; i < length; i++) {
		std::cout << *a++ << " ";
	}
	std::cout << endl;
}

//交换函数
void swap(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}
//冒泡排序
//参数a：数组的头指针
//参数lentgh：数组长度
void sort_by_point(int* a, int length) {

	int* p = a;

	for (int j = 0; j < length - 1; j++) {
		p = a;
		//一趟
		for (int i = 0; i < length - j - 1; i++) {
			if (*p > *(p+1)) {
				//交换
				swap(p, p+1);
			}
			p++;
		}
	}
}
```

注意：

> 使用指针对数组遍历的错误方法：
>
> ```c++
> *p = arr;
> 
> while(*p != NULL){
>     cout << *p++ << endl;
> }
> ```
>
> 因为在指针 `p` 越界后，`p` 指向的变量不一定是空值

> 传递数组的方法：
>
> ```c++
> //int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };
> 
> 返回值 函数名(int * arr, int len){...}
> 
> //或者 
> 
> 返回值 函数名(int arr[10]){...}//注意：是要有确切的长度
> ```

## 9  指针和引用的区别

### 9.1  相同点

### 9.2  不同点
